JavaScript unit testing is making my code worse
===============================================

:Date: 2013-10-19 16:05
:Tags: JavaScript, Qunit, sinon, mocking, Ajax, dependency injection
:Status: draft
:Author: Harry

tl;dr: I'm finding JavaScript unit testing quite painful, but worse
than that, it seems to make my code harder to read.  What am I doing
wrong?


I've been playing around with Mozilla Persona as an authentication 
platform, and I knocked together this basic code to interact with
their API.  You can see it's quite dense, but fairly readable:

We call a function called `watch`, passing it in an email address
string, and two callbacks for login and logout.  Login does a post,
refreshes the page if it succeeds, and calls a logout if it fails.
Logout just does a post and a refresh.  I'd say this is reasonably
OK code:


[source, javascript]
----
var currentUser = '{{ user.email }}' || null;
var csrf_token = '{{ csrf_token }}';

navigator.id.watch({
  loggedInUser: currentUser,
  onlogin: function(assertion) {
    $.post('/accounts/login', {assertion: assertion, csrfmiddlewaretoken: csrf_token})
    .done(function() { window.location.reload(); })
    .fail(function() { navigator.id.logout();});
  },
  onlogout: function() {
    $.post('/accounts/logout')
    .always(function() { window.location.reload(); });
  }
});
----

But look what happens to it once I try and unit test it:

[source, javascript]
----
$(document).ready(function() {

    var urls;
    var csrfToken;

    var initialize = function (navigator, user, token, urls_){
        urls = urls_;
        csrfToken = token;
        $('#id_login').on('click', function () {
            navigator.id.request();
        });

        navigator.id.watch({
            loggedInUser: user,
            onlogin: submitAssertion,
            onlogout: logOut,
        });
    };

    var submitAssertion = function (assertion) {
        $.post(
            urls.login,
            { assertion: assertion, csrfmiddlewaretoken: csrfToken }
        ).done( Superlists.Accounts.refreshPage );
    };

    var logOut = function () {};
    var refreshPage = function () {};

    $.extend(window.Superlists, {
        Accounts: {
            initialize: initialize,
            logOut: logOut,
            refreshPage: refreshPage,
            submitAssertion: submitAssertion
        }
    });

});
----

What's going on here?  At each stage I just tried to make sane, 
self-contained unit tests, and I end up with this long and, I think,
much less readable code!

Here's my first test for the original initialize function, which seemed 
a fairly sane way of passing all the "context" information from 
the template to javascript:

[source, javascript]
----
test("initialize binds sign in button to navigator.id.request", function () {
    var requestWasCalled = false;
    var mockRequestFunction = function() { requestWasCalled = true; };
    var mockNavigator = {
        id: {
            request: mockRequestFunction,
            watch: function () {}
        }
    };

    Superlists.Accounts.initialize(mockNavigator);
    equal(requestWasCalled, false, 'check request not called before click'); 

    $('#id_login').trigger('click');
    equal(requestWasCalled, true, 'check request called after click'); 
});
----

So, some ugly mocking there, and later on I'll use 'sinon.js' which will
make things easier, but, so far so good right?


Here's where things start to go wrong, I think:


[source, javascript]
----
test("initialize calls navigator.id.watch", function () {
    var user = 'current user';
    var token = 'csrf token';
    var urls = { login: 'login url', logout: 'logout url'};

    var watchFunctionCalled = false;
    var mockWatchFunction = function (params) {
        equal(params.loggedInUser, user, 'check user');
        equal(params.onlogin, Superlists.Accounts.submitAssertion, 'check login fn');
        equal(params.onlogout, Superlists.Accounts.logOut, 'check logout fn');
        watchFunctionCalled = true;
    };
    var mockNavigator = { id: { watch: mockWatchFunction } };

    Superlists.Accounts.initialize(mockNavigator, user, token, urls);

    equal(watchFunctionCalled, true, 'check watch function called');

});
----

As I say, sinon.js will make some of that mocking a little less painful,
but the basic assertions are the ones you need, right? 

