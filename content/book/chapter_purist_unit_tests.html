<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<title>Test Isolation, and "Listening to Your Tests"</title>
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
      var subheaders = document.getElementsByClassName('sectlevel2');
      var section;
      for (var i=0; i<subheaders.length; i++) {
        section = subheaders[i];
        if (section.innerHTML.indexOf(window.location.pathname) === -1) {
          section.style.display = 'none';
        } else {
          section.scrollIntoView && section.scrollIntoView();
        }
      }

    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_purist_unit_tests">Test Isolation, and "Listening to Your Tests"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In
the preceding chapter, we made the decision to leave a unit test failing in
the views layer while we proceeded to write more tests and more code at
the models layer to get it to pass.</p>
</div>
<div class="paragraph">
<p>We got away with it because our app was simple, but I should stress that,
in a more complex application, this would be a dangerous decision. Proceeding
to work on lower levels while you&#8217;re not sure that the higher levels are
<em>really</em> finished or not is a risky strategy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
I&#8217;m grateful to Gary Bernhardt, who took a look at an early draft of the
    previous chapter, and encouraged me to get into a longer discussion of test
    isolation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ensuring
isolation between layers does involve more effort (and more of the
dreaded mocks!), but it can also help to drive out improved design, as we&#8217;ll
see in this chapter.</p>
</div>
<div class="sect2">
<h3 id="_revisiting_our_decision_point_the_views_layer_depends_on_unwritten_models_code">Revisiting Our Decision Point: The Views Layer Depends on Unwritten Models Code</h3>
<div class="paragraph">
<p>Let&#8217;s
revisit the point we were at halfway through the last chapter, when we
couldn&#8217;t get the <code>new_list</code> view to work because lists didn&#8217;t have the <code>.owner</code>
attribute yet.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll actually go back in time and check out the old codebase using the tag we
saved earlier, so that we can see how things would have worked if we&#8217;d used
more isolated tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git checkout -b more-isolation</strong>  # a branch for this experiment
$ <strong>git reset --hard revisit_this_point_with_isolated_tests</strong></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s what our failing test looks like:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/tests/test_views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(<span class="predefined-constant">self</span>):
        user = User.objects.create(email=<span class="string"><span class="delimiter">'</span><span class="content">a@b.com</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.client.force_login(user)
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item</span><span class="delimiter">'</span></span>})
        list_ = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(list_.owner, user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s what our attempted solution looked like:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = ItemForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">form</span><span class="delimiter">"</span></span>: form})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And at this point, the view test is failing because we don&#8217;t have the model
layer yet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(list_.owner, user)
AttributeError: 'List' object has no attribute 'owner'</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You won&#8217;t see this error unless you actually check out the old code
    and revert <em>lists/models.py</em>.  You should definitely do this; part of
    the objective of this chapter is to see whether we really can write
    tests for a models layer that doesn&#8217;t exist yet.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_a_first_attempt_at_using_mocks_for_isolation">A First Attempt at Using Mocks for Isolation</h3>
<div class="paragraph">
<p>Lists
don&#8217;t have owners yet, but we can let the views layer tests pretend they
do by using a bit of mocking:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l003)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">unittest.mock</span> <span class="keyword">import</span> <span class="include">patch</span>
[...]

    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.List</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.ItemForm</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(
        <span class="predefined-constant">self</span>, mockItemFormClass, mockListClass  <i class="conum" data-value="3"></i><b>(3)</b>
    ):
        user = User.objects.create(email=<span class="string"><span class="delimiter">'</span><span class="content">a@b.com</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.client.force_login(user)

        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item</span><span class="delimiter">'</span></span>})

        mock_list = mockListClass.return_value  <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="predefined-constant">self</span>.assertEqual(mock_list.owner, user)  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We mock out the <code>List</code> class to be able to get access to any lists
that might be created by the view.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also mock out the <code>ItemForm</code>. Otherwise, our form will
raise an error when we call <code>form.save()</code>, because it can&#8217;t use a
mock object as the foreign key for the <code>Item</code> it wants to create.
Once you start mocking, it can be hard to stop!</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The mock objects are injected into the test&#8217;s arguments in the
opposite order to which they&#8217;re declared. Tests with lots of mocks
often have this strange signature, with the dangling <code>):</code>.  You get
used to it!</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The list instance that the view will have access to
will be the return value of the mocked <code>List</code> class.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>And we can make assertions about whether the <code>.owner</code> attribute is set on
it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If we try to run this test now, it should pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 37 tests in 0.145s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t see a pass, make sure that your views code in <em>views.py</em> is
exactly as I&#8217;ve shown it, using <code>List()</code>, not <code>List.objects.create</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using mocks does tie you to specific ways of using an API.  This is one
    of the many trade-offs involved in the use of mock objects.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_using_mock_side_effects_to_check_the_sequence_of_events">Using Mock side_effects to Check the Sequence of Events</h4>
<div class="paragraph">
<p>The trouble with this test is that it can still let us get away with writing
the wrong code by mistake.  Imagine if we accidentally call <code>save</code> before we
we assign the owner:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        list_.save()
        list_.owner = request.user
        form.save(for_list=list_)
        <span class="keyword">return</span> redirect(list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The test, as it&#8217;s written now, still passes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
<div class="paragraph">
<p>So strictly speaking, we need to check not just that the owner is assigned, but that
it&#8217;s assigned <em>before</em> we call <code>save</code> on our list object.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how we could test the sequence of events using mocks&#8212;&#8203;you can mock out
a function, and use it as a spy to check on the state of the world at the
moment it&#8217;s called:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l005)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.List</span><span class="delimiter">'</span></span>)
    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.ItemForm</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(
        <span class="predefined-constant">self</span>, mockItemFormClass, mockListClass
    ):
        user = User.objects.create(email=<span class="string"><span class="delimiter">'</span><span class="content">a@b.com</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.client.force_login(user)
        mock_list = mockListClass.return_value

        <span class="keyword">def</span> <span class="function">check_owner_assigned</span>():  <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="predefined-constant">self</span>.assertEqual(mock_list.owner, user)
        mock_list.save.side_effect = check_owner_assigned  <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item</span><span class="delimiter">'</span></span>})

        mock_list.save.assert_called_once_with()  <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a function that makes the assertion about the thing we
want to happen first: checking that the list&#8217;s owner has been set.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We assign that check function as a <code>side_effect</code> to the thing we
want to check happened second.  When the view calls our mocked
save function, it will go through this assertion.  We make sure to
set this up before we actually call the function we&#8217;re testing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, we make sure that the function with the <code>side_effect</code> was
actually triggered&#8212;&#8203;that is, that we did <code>.save()</code>.  Otherwise, our
assertion may actually never have been run.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Two common mistakes when you&#8217;re using mock side effects are assigning the
    side effect too late (i.e., <em>after</em> you call the function under test), and
    forgetting to check that the side-effect function was actually called. And
    by common, I mean, "I made both these mistakes several times <em>while writing
    this chapter</em>.&#8221;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At this point, if you&#8217;ve still got the "broken" code from earlier, where we
assign the owner but call <code>save</code> in the wrong order, you should now see a
fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_list_owner_is_saved_if_user_is_authenticated
(lists.tests.test_views.NewListTest)
[...]
  File "...python-tdd-book/lists/views.py", line 17, in new_list
    list_.save()
[...]
  File "...python-tdd-book/lists/tests/test_views.py", line 74, in
check_owner_assigned
    self.assertEqual(mock_list.owner, user)
AssertionError: &lt;MagicMock name='List().owner' id='140691452447208'&gt; != &lt;User:
User object&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the failure happens when we try to save, and then go inside
our <code>side_effect</code> function.</p>
</div>
<div class="paragraph">
<p>We can get it passing again like this:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        <span class="keyword">return</span> redirect(list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
<div class="paragraph">
<p>But, boy, that&#8217;s getting to be an ugly test!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listen_to_your_tests_ugly_tests_signal_a_need_to_refactor">Listen to Your Tests: Ugly Tests Signal a Need to Refactor</h3>
<div class="paragraph">
<p>Whenever
you find yourself having to write a test like this, and you&#8217;re finding
it hard work, it&#8217;s likely that your tests are trying to tell you something.
Eight lines of setup (two lines for mocks, three to set up a user, and three more for our side-effect function) is way too many.</p>
</div>
<div class="paragraph">
<p>What this test is trying to tell us is that our view is doing too much work,
dealing with creating a form, creating a new list object, <em>and</em> deciding whether
or not to save an owner for the list.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve already seen that we can make our views simpler and easier to understand
by pushing some of the work down to a form class. Why does the view need to
create the list object?  Perhaps our <code>ItemForm.save</code> could do that?  And why
does the view need to make decisions about whether or not to save the
<code>request.user</code>?  Again, the form could do that.</p>
</div>
<div class="paragraph">
<p>While we&#8217;re giving this form more responsibilities, it feels like it should
probably get a new name too.  We could call it <code>NewListForm</code> instead, since
that&#8217;s a better representation of what it does&#8230;&#8203;something like this?</p>
</div>
<div class="exampleblock sourcecode skipme">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="comment"># don't enter this code yet, we're only imagining it.</span>

<span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = NewListForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = form.save(owner=request.user)  <span class="comment"># creates both List and Item</span>
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">form</span><span class="delimiter">"</span></span>: form})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That would be neater!  Let&#8217;s see how we&#8217;d get to that state by using
fully isolated tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rewriting_our_tests_for_the_view_to_be_fully_isolated">Rewriting Our Tests for the View to Be Fully Isolated</h3>
<div class="paragraph">
<p>Our
first attempt at a test suite for this view was highly <em>integrated</em>.  It
needed the database layer and the forms layer to be fully functional in order
for it to pass.   We&#8217;ve started trying to make it more isolated, so let&#8217;s now go
all the way.</p>
</div>
<div class="sect3">
<h4 id="_keep_the_old_integrated_test_suite_around_as_a_sanity_check">Keep the Old Integrated Test Suite Around as a Sanity Check</h4>
<div class="paragraph">
<p>Let&#8217;s rename our old <code>NewListTest</code> class to <code>NewListViewIntegratedTest</code>,
and throw away our attempt at a mocky test for saving the owner, putting
back the integrated version, with a skip on it for now:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l008)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">import</span> <span class="include">unittest</span>
[...]

<span class="keyword">class</span> <span class="class">NewListViewIntegratedTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="decorator">@unittest.skip</span>
    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(<span class="predefined-constant">self</span>):
        user = User.objects.create(email=<span class="string"><span class="delimiter">'</span><span class="content">a@b.com</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.client.force_login(user)
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item</span><span class="delimiter">'</span></span>})
        list_ = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(list_.owner, user)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Have you heard the term "integration test" and are wondering what the
    difference is from an "integrated test"?  Go and take a peek at the
    definitions box in <a href="/book/chapter_hot_lava.html">[chapter_hot_lava]</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 37 tests in 0.139s
OK</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_new_test_suite_with_full_isolation">A New Test Suite with Full Isolation</h4>
<div class="paragraph">
<p>Let&#8217;s start with a blank slate, and see if we can use isolated tests to drive
a replacement of our <code>new_list</code> view.  We&#8217;ll call it <code>new_list2</code>, build it
alongside the old view, and when we&#8217;re ready, swap it in and see if
the old integrated tests all still pass:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l009)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    [...]

<span class="keyword">def</span> <span class="function">new_list2</span>(request):
    <span class="keyword">pass</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_thinking_in_terms_of_collaborators">Thinking in Terms of Collaborators</h4>
<div class="paragraph">
<p>In order to rewrite our tests to be fully isolated, we need to throw out our
old way of thinking about the tests in terms of the "real" effects of the view
on things like the database, and instead think of it in terms of the objects it
collaborates with, and how it interacts with them.</p>
</div>
<div class="paragraph">
<p>In the new world, the view&#8217;s main collaborator will be a form object, so we
mock that out in order to be able to fully control it, and in order to be able
to define, by wishful thinking, the way we want our form to work:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l010)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">unittest.mock</span> <span class="keyword">import</span> <span class="include">patch</span>
<span class="keyword">from</span> <span class="include">django.http</span> <span class="keyword">import</span> <span class="include">HttpRequest</span>
<span class="keyword">from</span> <span class="include">lists.views</span> <span class="keyword">import</span> <span class="include">new_list2</span>
[...]

<span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.NewListForm</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="keyword">class</span> <span class="class">NewListViewUnitTest</span>(unittest.TestCase):  <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.request = HttpRequest()
        <span class="predefined-constant">self</span>.request.POST[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>] = <span class="string"><span class="delimiter">'</span><span class="content">new list item</span><span class="delimiter">'</span></span>  <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="keyword">def</span> <span class="function">test_passes_POST_data_to_NewListForm</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        new_list2(<span class="predefined-constant">self</span>.request)
        mockNewListForm.assert_called_once_with(data=<span class="predefined-constant">self</span>.request.POST)  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The Django <code>TestCase</code> class makes it too easy to write integrated tests.
As a way of making sure we&#8217;re writing "pure", isolated unit tests, we&#8217;ll
only use <code>unittest.TestCase</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We mock out the <code>NewListForm</code> class (which doesn&#8217;t even exist yet). It&#8217;s
going to be used in all the tests, so we mock it out at the class level.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We set up a basic POST request in <code>setUp</code>, building up the request by
hand rather than using the (overly integrated) Django Test Client.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And we check the first thing about our new view: it initialises its
collaborator, the <code>NewListForm</code>, with the correct constructor&#8212;&#8203;the
data from the request.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That will start with a failure, saying we don&#8217;t have a <code>NewListForm</code> in
our view yet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AttributeError: &lt;module 'lists.views' from '...python-tdd-book/lists/views.py'&gt;
does not have the attribute 'NewListForm'</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s create a placeholder for it:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l011)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">lists.forms</span> <span class="keyword">import</span> <span class="include">ExistingListItemForm</span>, <span class="include">ItemForm</span>, <span class="include">NewListForm</span>
[...]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/forms.py (ch20l012)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ItemForm</span>(forms.models.ModelForm):
    [...]

<span class="keyword">class</span> <span class="class">NewListForm</span>(<span class="predefined">object</span>):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="class">ExistingListItemForm</span>(ItemForm):
    [...]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Next we get a real failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: Expected 'NewListForm' to be called once. Called 0 times.</pre>
</div>
</div>
<div class="paragraph">
<p>And we implement like this:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l012-2)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list2</span>(request):
    NewListForm(data=request.POST)</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 38 tests in 0.143s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s continue.  If the form is valid, we want to call <code>save</code> on it:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l013)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">unittest.mock</span> <span class="keyword">import</span> <span class="include">patch</span>, <span class="include">Mock</span>
[...]

<span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.NewListForm</span><span class="delimiter">'</span></span>)
<span class="keyword">class</span> <span class="class">NewListViewUnitTest</span>(unittest.TestCase):

    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.request = HttpRequest()
        <span class="predefined-constant">self</span>.request.POST[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>] = <span class="string"><span class="delimiter">'</span><span class="content">new list item</span><span class="delimiter">'</span></span>
        <span class="predefined-constant">self</span>.request.user = Mock()


    <span class="keyword">def</span> <span class="function">test_passes_POST_data_to_NewListForm</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        new_list2(<span class="predefined-constant">self</span>.request)
        mockNewListForm.assert_called_once_with(data=<span class="predefined-constant">self</span>.request.POST)


    <span class="keyword">def</span> <span class="function">test_saves_form_with_owner_if_form_valid</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">True</span>
        new_list2(<span class="predefined-constant">self</span>.request)
        mock_form.save.assert_called_once_with(owner=<span class="predefined-constant">self</span>.request.user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph pagebreak-before">
<p>That takes us to this:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l014)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list2</span>(request):
    form = NewListForm(data=request.POST)
    form.save(owner=request.user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the case where the form is valid, we want the view to return a redirect,
to send us to see the object that the form has just created.  So we mock out
another of the view&#8217;s collaborators, the <code>redirect</code> function:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l015)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.redirect</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">def</span> <span class="function">test_redirects_to_form_returned_object_if_form_valid</span>(
        <span class="predefined-constant">self</span>, mock_redirect, mockNewListForm  <i class="conum" data-value="2"></i><b>(2)</b>
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">True</span>  <i class="conum" data-value="3"></i><b>(3)</b>

        response = new_list2(<span class="predefined-constant">self</span>.request)

        <span class="predefined-constant">self</span>.assertEqual(response, mock_redirect.return_value)  <i class="conum" data-value="4"></i><b>(4)</b>
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We mock out the <code>redirect</code> function, this time at the method level.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>patch</code> decorators are applied innermost first, so the new mock is injected
to our method before the <code>mockNewListForm</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We specify that we&#8217;re testing the case where the form is valid.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We check that the response from the view is the result of the <code>redirect</code>
function.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>And we check that the redirect function was called with the object that
the form returns on save.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That takes us to here:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l016)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list2</span>(request):
    form = NewListForm(data=request.POST)
    list_ = form.save(owner=request.user)
    <span class="keyword">return</span> redirect(list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 40 tests in 0.163s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>And now the failure case&#8212;&#8203;if the form is invalid, we want to render
the home page template:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l017)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.render</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_renders_home_template_with_form_if_form_invalid</span>(
        <span class="predefined-constant">self</span>, mock_render, mockNewListForm
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">False</span>

        response = new_list2(<span class="predefined-constant">self</span>.request)

        <span class="predefined-constant">self</span>.assertEqual(response, mock_render.return_value)
        mock_render.assert_called_once_with(
            <span class="predefined-constant">self</span>.request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">form</span><span class="delimiter">'</span></span>: mock_form}
        )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That gives us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: &lt;HttpResponseRedirect status_code=302, "te[114 chars]%3E"&gt; !=
&lt;MagicMock name='render()' id='140244627467408'&gt;</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When using assert methods on mocks, like <code>assert_called_&#8203;once_with</code>,
    it&#8217;s doubly important to make sure you run the test and see it fail.
    It&#8217;s all too easy to make a typo in your assert function name and
    end up calling a mock method that does nothing (mine was to write
    <code>asssert_called_once_with</code> with three essses; try it!).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We make a deliberate mistake, just to make sure our tests are comprehensive:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l018)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list2</span>(request):
    form = NewListForm(data=request.POST)
    list_ = form.save(owner=request.user)
    <span class="keyword">if</span> form.is_valid():
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">form</span><span class="delimiter">'</span></span>: form})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That passes, but it shouldn&#8217;t!  One more test then:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l019)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_does_not_save_if_form_invalid</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">False</span>
        new_list2(<span class="predefined-constant">self</span>.request)
        <span class="predefined-constant">self</span>.assertFalse(mock_form.save.called)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Which fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertFalse(mock_form.save.called)
AssertionError: True is not false</pre>
</div>
</div>
<div class="paragraph">
<p>And
we get to to our neat, small finished view:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list2</span>(request):
    form = NewListForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = form.save(owner=request.user)
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">form</span><span class="delimiter">'</span></span>: form})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 42 tests in 0.163s
OK</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_moving_down_to_the_forms_layer">Moving Down to the Forms Layer</h3>
<div class="paragraph">
<p>So
we&#8217;ve built up our view function based on a "wishful thinking" version
of a form called <code>NewListForm</code>, which doesn&#8217;t even exist yet.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll need the form&#8217;s save method to create a new list, and a new item based on
the text from the form&#8217;s validated POST data.  If we were to just dive in and
use the ORM, the code might look something a bit like this:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListForm</span>(models.Form):

    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>, owner):
        list_ = List()
        <span class="keyword">if</span> owner:
            list_.owner = owner
        list_.save()
        item = Item()
        item.list = list_
        item.text = <span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>]
        item.save()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This implementation depends on two classes from the model layer, <code>Item</code> and
<code>List</code>.  So, what would a well-isolated test look like?</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListFormTest</span>(unittest.TestCase):

    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.forms.List</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.forms.Item</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">def</span> <span class="function">test_save_creates_new_list_and_item_from_post_data</span>(
        <span class="predefined-constant">self</span>, mockItem, mockList  <i class="conum" data-value="1"></i><b>(1)</b>
    ):
        mock_item = mockItem.return_value
        mock_list = mockList.return_value
        user = Mock()
        form = NewListForm(data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>})
        form.is_valid() <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="keyword">def</span> <span class="function">check_item_text_and_list</span>():
            <span class="predefined-constant">self</span>.assertEqual(mock_item.text, <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>)
            <span class="predefined-constant">self</span>.assertEqual(mock_item.list, mock_list)
            <span class="predefined-constant">self</span>.assertTrue(mock_list.save.called)
        mock_item.save.side_effect = check_item_text_and_list  <i class="conum" data-value="3"></i><b>(3)</b>

        form.save(owner=user)

        <span class="predefined-constant">self</span>.assertTrue(mock_item.save.called)  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We mock out the two collaborators for our form from the models layer below.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need to call <code>is_valid()</code> so that the form populates the <code>.cleaned_data</code>
dictionary where it stores validated data.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We use the <code>side_effect</code> method to make sure that, when we save the new
item object, we&#8217;re doing so with a saved <code>List</code> and with the correct item
text.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>As always, we double-check that our side-effect function was actually
called.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Yuck!  What an ugly test!  Let&#8217;s not even bother saving that to disk,
we can do better.</p>
</div>
<div class="sect3">
<h4 id="_keep_listening_to_your_tests_removing_orm_code_from_our_application">Keep Listening to Your Tests: Removing ORM Code from Our Application</h4>
<div class="paragraph">
<p>Again, these tests are trying to tell us something:  the Django ORM
is hard to mock out, and our form class needs to know too much about
how it works.  Programming by wishful thinking again, what would
be a simpler API that our form could use?  How about something like
this:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>):
        List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our wishful thinking says: how about a helper method that
would live on the <code>List</code>
class<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>
and encapsulate all the logic of saving a new list object and
its associated first item?</p>
</div>
<div class="paragraph">
<p>So let&#8217;s write a test for that instead:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_forms.py (ch20l021)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">import</span> <span class="include">unittest</span>
<span class="keyword">from</span> <span class="include">unittest.mock</span> <span class="keyword">import</span> <span class="include">patch</span>, <span class="include">Mock</span>
<span class="keyword">from</span> <span class="include">django.test</span> <span class="keyword">import</span> <span class="include">TestCase</span>

<span class="keyword">from</span> <span class="include">lists.forms</span> <span class="keyword">import</span> (
    DUPLICATE_ITEM_ERROR, EMPTY_ITEM_ERROR,
    ExistingListItemForm, ItemForm, NewListForm
)
<span class="keyword">from</span> <span class="include">lists.models</span> <span class="keyword">import</span> <span class="include">Item</span>, <span class="include">List</span>
[...]


<span class="keyword">class</span> <span class="class">NewListFormTest</span>(unittest.TestCase):

    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.forms.List.create_new</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_save_creates_new_list_from_post_data_if_user_not_authenticated</span>(
        <span class="predefined-constant">self</span>, mock_List_create_new
    ):
        user = Mock(is_authenticated=<span class="predefined-constant">False</span>)
        form = NewListForm(data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>})
        form.is_valid()
        form.save(owner=user)
        mock_List_create_new.assert_called_once_with(
            first_item_text=<span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>
        )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph pagebreak-before">
<p>And while we&#8217;re at it, we can test the case where the user is an authenticated
user too:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_forms.py (ch20l022)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.forms.List.create_new</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_save_creates_new_list_with_owner_if_user_authenticated</span>(
        <span class="predefined-constant">self</span>, mock_List_create_new
    ):
        user = Mock(is_authenticated=<span class="predefined-constant">True</span>)
        form = NewListForm(data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>})
        form.is_valid()
        form.save(owner=user)
        mock_List_create_new.assert_called_once_with(
            first_item_text=<span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>, owner=user
        )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can see this is a much more readable test. Let&#8217;s start implementing
our new form.  We start with the import:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/forms.py (ch20l023)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">lists.models</span> <span class="keyword">import</span> <span class="include">Item</span>, <span class="include">List</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now mock tells us to create a placeholder for our <code>create_new</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AttributeError: &lt;class 'lists.models.List'&gt; does not have the attribute
'create_new'</pre>
</div>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">List</span>(models.Model):

    <span class="keyword">def</span> <span class="function">get_absolute_url</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> reverse(<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>, args=[<span class="predefined-constant">self</span>.id])

    <span class="keyword">def</span> <span class="function">create_new</span>():
        <span class="keyword">pass</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And after a few steps, we should end up with a form save method like this:</p>
</div>
<div class="exampleblock sourcecode small-code">
<div class="title">lists/forms.py (ch20l025)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListForm</span>(ItemForm):

    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>, owner):
        <span class="keyword">if</span> owner.is_authenticated:
            List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>], owner=owner)
        <span class="keyword">else</span>:
            List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And passing tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
Ran 44 tests in 0.192s
OK</pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Hiding ORM Code Behind Helper Methods</div>
<div class="paragraph">
<p>One
of the techniques that emerged from our use of isolated tests was the
"ORM helper method".</p>
</div>
<div class="paragraph">
<p>Django&#8217;s ORM lets you get things done quickly with a reasonably readable
syntax (it&#8217;s certainly much nicer than raw SQL!).  But some people like to
try to minimise the amount of ORM code in the application&#8212;&#8203;particularly
removing it from the views and forms layers.</p>
</div>
<div class="paragraph">
<p>One reason is that it makes it much easier to test those layers.  But another
is that it forces us to build helper functions that express our domain
logic more clearly. <span class="keep-together">Compare</span>:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">        list_ = List()
        list_.save()
        item = Item()
        item.list = list_
        item.text = <span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>]
        item.save()</code></pre>
</div>
</div>
<div class="paragraph">
<p>With:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This applies to read queries as well as write. Imagine something like
this:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    Book.objects.filter(in_print=<span class="predefined-constant">True</span>, pub_date__lte=datetime.today())</code></pre>
</div>
</div>
<div class="paragraph">
<p>Versus a helper method, like:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    Book.all_available_books()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we build helper functions, we can give them names that express what we
are doing in terms of the business domain, which can actually make our code
more legible, as well as giving us the benefit of keeping all ORM calls at
the model layer, and thus making our whole application more loosely coupled.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finally_moving_down_to_the_models_layer">Finally, Moving Down to the Models Layer</h3>
<div class="paragraph">
<p>At
the models layer, we no longer need to write isolated tests&#8212;&#8203;the whole
point of the models layer is to integrate with the database, so it&#8217;s appropriate
to write integrated tests:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l026)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListModelTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_get_absolute_url</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        <span class="predefined-constant">self</span>.assertEqual(list_.get_absolute_url(), f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{list_.id}/</span><span class="delimiter">'</span></span>)


    <span class="keyword">def</span> <span class="function">test_create_new_creates_list_and_first_item</span>(<span class="predefined-constant">self</span>):
        List.create_new(first_item_text=<span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>)
        new_item = Item.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>)
        new_list = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.list, new_list)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Which gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>TypeError: create_new() got an unexpected keyword argument 'first_item_text'</pre>
</div>
</div>
<div class="paragraph">
<p>And that will take us to a first cut implementation that looks like this:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py (ch20l027)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">List</span>(models.Model):

    <span class="keyword">def</span> <span class="function">get_absolute_url</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> reverse(<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>, args=[<span class="predefined-constant">self</span>.id])

    <span class="decorator">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">create_new</span>(first_item_text):
        list_ = List.objects.create()
        Item.objects.create(text=first_item_text, list=list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice we&#8217;ve been able to get all the way down to the models layer,
driving a nice design for the views and forms layers, and the <code>List</code>
model still doesn&#8217;t support having an owner!</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s test the case where the list should have an owner, and
add:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l028)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.contrib.auth</span> <span class="keyword">import</span> <span class="include">get_user_model</span>
User = get_user_model()
[...]

    <span class="keyword">def</span> <span class="function">test_create_new_optionally_saves_owner</span>(<span class="predefined-constant">self</span>):
        user = User.objects.create()
        List.create_new(first_item_text=<span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>, owner=user)
        new_list = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_list.owner, user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And while we&#8217;re at it, we can write the tests for the new owner attribute:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l029)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListModelTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_lists_can_have_owners</span>(<span class="predefined-constant">self</span>):
        List(owner=User())  <span class="comment"># should not raise</span>


    <span class="keyword">def</span> <span class="function">test_list_owner_is_optional</span>(<span class="predefined-constant">self</span>):
        List().full_clean()  <span class="comment"># should not raise</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These two are almost exactly the same tests we used in the last chapter,
but I&#8217;ve re-written them slightly so they don&#8217;t actually save objects&#8212;&#8203;just
having them as in-memory objects is enough for this test.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use in-memory (unsaved) model objects in your tests whenever you can; it
    makes your tests faster.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
ERROR: test_create_new_optionally_saves_owner
TypeError: create_new() got an unexpected keyword argument 'owner'
[...]
ERROR: test_lists_can_have_owners (lists.tests.test_models.ListModelTest)
TypeError: 'owner' is an invalid keyword argument for this function
[...]
Ran 48 tests in 0.204s
FAILED (errors=2)</pre>
</div>
</div>
<div class="paragraph">
<p>We implement, just like we did in the last chapter:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py (ch20l030-1)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.conf</span> <span class="keyword">import</span> <span class="include">settings</span>
[...]


<span class="keyword">class</span> <span class="class">List</span>(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=<span class="predefined-constant">True</span>, null=<span class="predefined-constant">True</span>)
    [...]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That will give us the usual integrity failures, until we do a migration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>django.db.utils.OperationalError: no such column: lists_list.owner_id</pre>
</div>
</div>
<div class="paragraph">
<p>Building the migration will get us down to three failures:</p>
</div>
<div class="listingblock dofirst-ch20l030-2">
<div class="content">
<pre>ERROR: test_create_new_optionally_saves_owner
TypeError: create_new() got an unexpected keyword argument 'owner'
[...]
ValueError: Cannot assign "&lt;SimpleLazyObject:
&lt;django.contrib.auth.models.AnonymousUser object at 0x7f5b2380b4e0&gt;&gt;":
"List.owner" must be a "User" instance.
ValueError: Cannot assign "&lt;SimpleLazyObject:
&lt;django.contrib.auth.models.AnonymousUser object at 0x7f5b237a12e8&gt;&gt;":
"List.owner" must be a "User" instance.</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s deal with the first one, which is for our <code>create_new</code> method:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py (ch20l030-3)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">create_new</span>(first_item_text, owner=<span class="predefined-constant">None</span>):
        list_ = List.objects.create(owner=owner)
        Item.objects.create(text=first_item_text, list=list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_back_to_views">Back to Views</h4>
<div class="paragraph">
<p>Two of our old integrated tests for the views layer are failing. What&#8217;s happening?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ValueError: Cannot assign "&lt;SimpleLazyObject:
&lt;django.contrib.auth.models.AnonymousUser object at 0x7fbad1cb6c10&gt;&gt;":
"List.owner" must be a "User" instance.</pre>
</div>
</div>
<div class="paragraph">
<p>Ah, the old view isn&#8217;t discerning enough about what it does with list
owners yet:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is the point at which we realise that our old code wasn&#8217;t fit for purpose.
Let&#8217;s fix it to get all our tests passing:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l031)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = ItemForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        <span class="keyword">if</span> request.user.is_authenticated:
            list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">form</span><span class="delimiter">"</span></span>: form})


<span class="keyword">def</span> <span class="function">new_list2</span>(request):
    [...]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One
of the benefits of integrated tests is that they help you to catch
    less predictable interactions like this.  We&#8217;d forgotten to write a test
    for the case where the user is not authenticated, but because the
    integrated tests use the stack all the way down, errors from the model
    layer came up to let us know we&#8217;d forgotten something:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 48 tests in 0.175s
OK</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_moment_of_truth_and_the_risks_of_mocking">The Moment of Truth (and the Risks of Mocking)</h3>
<div class="paragraph">
<p>So
let&#8217;s try switching out our old view, and activating our new view. We
can make the swap in <em>urls.py</em>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/urls.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">[...]
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list2, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We should also remove the <code>unittest.skip</code> from our integrated test class, to
see if our new code for list owners really works:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l033)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListViewIntegratedTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(<span class="predefined-constant">self</span>):
        [...]
        <span class="predefined-constant">self</span>.assertEqual(list_.owner, user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So what happens when we run our tests? Oh no!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: test_list_owner_is_saved_if_user_is_authenticated
[...]
ERROR: test_can_save_a_POST_request
[...]
ERROR: test_redirects_after_POST
(lists.tests.test_views.NewListViewIntegratedTest)
  File "...python-tdd-book/lists/views.py", line 30, in new_list2
    return redirect(list_)
[...]
TypeError: argument of type 'NoneType' is not iterable

FAILED (errors=3)</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an important lesson to learn about test isolation: it might help you
to drive out good design for individual layers, but it won&#8217;t automatically
verify the integration <em>between</em> your layers.</p>
</div>
<div class="paragraph">
<p>What&#8217;s happened here is that the view was expecting the form to return
a list item:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">        list_ = form.save(owner=request.user)
        <span class="keyword">return</span> redirect(list_)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>But we forgot to make it return anything:</p>
</div>
<div class="exampleblock sourcecode currentcontents small-code">
<div class="title">lists/forms.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>, owner):
        <span class="keyword">if</span> owner.is_authenticated:
            List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>], owner=owner)
        <span class="keyword">else</span>:
            List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_thinking_of_interactions_between_layers_as_contracts">Thinking of Interactions Between Layers as "Contracts"</h3>
<div class="paragraph">
<p>Ultimately, even if we had been writing nothing but isolated unit tests, our
functional tests would have picked up this particular slip-up.  But ideally
we&#8217;d want our feedback cycle to be quicker&#8212;&#8203;functional tests may take a
couple of minutes to run, or even a few hours once your app starts to grow.  Is
there any way to avoid this sort of problem before it happens?</p>
</div>
<div class="paragraph">
<p>Methodologically, the way to do it is to think about the interaction between
your layers in terms of contracts.  Whenever we mock out the behaviour of one
layer, we have to make a mental note that there is now an implicit contract
between the layers, and that a mock on one layer should probably translate into
a test at the layer below.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the part of the contract that we missed:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/tests/test_views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.redirect</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_redirects_to_form_returned_object_if_form_valid</span>(
        <span class="predefined-constant">self</span>, mock_redirect, mockNewListForm
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">True</span>

        response = new_list2(<span class="predefined-constant">self</span>.request)

        <span class="predefined-constant">self</span>.assertEqual(response, mock_redirect.return_value)
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The mocked <code>form.save</code> function is returning an object, which we expect
our view to be able to use.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_identifying_implicit_contracts">Identifying Implicit Contracts</h4>
<div class="paragraph">
<p>It&#8217;s worth reviewing each of the tests in <code>NewListViewUnitTest</code> and seeing
what each mock is saying about the implicit contract:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">lists/tests/test_views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_passes_POST_data_to_NewListForm</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        [...]
        mockNewListForm.assert_called_once_with(data=<span class="predefined-constant">self</span>.request.POST)  <i class="conum" data-value="1"></i><b>(1)</b>


    <span class="keyword">def</span> <span class="function">test_saves_form_with_owner_if_form_valid</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = <span class="predefined-constant">True</span>  <i class="conum" data-value="2"></i><b>(2)</b>
        new_list2(<span class="predefined-constant">self</span>.request)
        mock_form.save.assert_called_once_with(owner=<span class="predefined-constant">self</span>.request.user)  <i class="conum" data-value="3"></i><b>(3)</b>


    <span class="keyword">def</span> <span class="function">test_does_not_save_if_form_invalid</span>(<span class="predefined-constant">self</span>, mockNewListForm):
        [...]
        mock_form.is_valid.return_value = <span class="predefined-constant">False</span>  <i class="conum" data-value="2"></i><b>(2)</b>
        [...]


    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.redirect</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_redirects_to_form_returned_object_if_form_valid</span>(
        <span class="predefined-constant">self</span>, mock_redirect, mockNewListForm
    ):
        [...]
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  <i class="conum" data-value="4"></i><b>(4)</b>


    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.views.render</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_renders_home_template_with_form_if_form_invalid</span>(
        [...]</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We need to be able to initialise our form by passing it a POST request
as data.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It should have an <code>is_valid()</code> function which returns <code>True</code> or <code>False</code>
appropriately, based on the input data.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The form should have a <code>.save</code> method which will accept a <code>request.user</code>,
which may or may not be a logged-in user, and deal with it appropriately.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The form&#8217;s <code>.save</code> method should return a new list object, for our view
to redirect the user to.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If we have a look through our form tests, we&#8217;ll see that, actually, only item (3)
is tested explicitly.  On items (1) and (2) we were lucky&#8212;&#8203;they&#8217;re default
features of a Django <code>ModelForm</code>, and they are actually covered by our
tests for the parent <code>ItemForm</code> class.</p>
</div>
<div class="paragraph">
<p>But contract clause number (4) managed to slip through the net.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When doing Outside-In TDD with isolated tests, you need to keep track of
    each test&#8217;s implicit assumptions about the contract which the next layer
    should implement, and remember to test each of those in turn later.  You
    could use our scratchpad for this, or create a placeholder test with
    a <code>self.fail</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fixing_the_oversight">Fixing the Oversight</h4>
<div class="paragraph">
<p>Let&#8217;s add a new test that our form should return the new saved list:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_forms.py (ch20l038-1)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">lists.forms.List.create_new</span><span class="delimiter">'</span></span>)
    <span class="keyword">def</span> <span class="function">test_save_returns_new_list_object</span>(<span class="predefined-constant">self</span>, mock_List_create_new):
        user = Mock(is_authenticated=<span class="predefined-constant">True</span>)
        form = NewListForm(data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>})
        form.is_valid()
        response = form.save(owner=user)
        <span class="predefined-constant">self</span>.assertEqual(response, mock_List_create_new.return_value)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And, actually, this is a good example&#8212;&#8203;we have an implicit contract
with the <code>List.create_new</code>; we want it to return the new list object.
Let&#8217;s add a placeholder test for that:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l038-2)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListModelTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_create_returns_new_list_object</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.fail()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So, we have one test failure that&#8217;s telling us to fix the form save:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: None != &lt;MagicMock name='create_new()' id='139802647565536'&gt;
FAILED (failures=2, errors=3)</pre>
</div>
</div>
<div class="paragraph">
<p>Like this:</p>
</div>
<div class="exampleblock sourcecode small-code">
<div class="title">lists/forms.py (ch20l039-1)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListForm</span>(ItemForm):

    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>, owner):
        <span class="keyword">if</span> owner.is_authenticated:
            <span class="keyword">return</span> List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>], owner=owner)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> List.create_new(first_item_text=<span class="predefined-constant">self</span>.cleaned_data[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s a start; now we should look at our placeholder test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[...]
FAIL: test_create_returns_new_list_object
    self.fail()
AssertionError: None

FAILED (failures=1, errors=3)</pre>
</div>
</div>
<div class="paragraph">
<p>We flesh it out:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l039-2)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_create_returns_new_list_object</span>(<span class="predefined-constant">self</span>):
        returned = List.create_new(first_item_text=<span class="string"><span class="delimiter">'</span><span class="content">new item text</span><span class="delimiter">'</span></span>)
        new_list = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(returned, new_list)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: None != &lt;List: List object&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>And we add our return value:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py (ch20l039-3)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@staticmethod</span>
    <span class="keyword">def</span> <span class="function">create_new</span>(first_item_text, owner=<span class="predefined-constant">None</span>):
        list_ = List.objects.create(owner=owner)
        Item.objects.create(text=first_item_text, list=list_)
        <span class="keyword">return</span> list_</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And
that gets us to a fully passing test suite:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 50 tests in 0.169s

OK</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_one_more_test">One More Test</h3>
<div class="paragraph">
<p>That&#8217;s our code for saving list owners, test-driven all the way down and
working.  But our functional test isn&#8217;t passing quite yet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_my_lists</strong>
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Reticulate splines</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s because we have one last feature to implement, the <code>.name</code> attribute on list
objects.  Again, we can grab the test and code from the last chapter:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_models.py (ch20l040)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_list_name_is_first_item_text</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text=<span class="string"><span class="delimiter">'</span><span class="content">first item</span><span class="delimiter">'</span></span>)
        Item.objects.create(list=list_, text=<span class="string"><span class="delimiter">'</span><span class="content">second item</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertEqual(list_.name, <span class="string"><span class="delimiter">'</span><span class="content">first item</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(Again, since this is a model-layer test, it&#8217;s OK to use the ORM. You could
conceivably write this test using mocks, but there wouldn&#8217;t be much point.)</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/models.py (ch20l041)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@property</span>
    <span class="keyword">def</span> <span class="function">name</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> <span class="predefined-constant">self</span>.item_set.first().text</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And that gets us to a passing FT!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_my_lists</strong>

Ran 1 test in 21.428s

OK</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tidy_up_what_to_keep_from_our_integrated_test_suite">Tidy Up: What to Keep from Our Integrated Test Suite</h3>
<div class="paragraph">
<p>Now
everything is working, we can remove some redundant tests, and decide
whether we want to keep any of our old integrated tests.</p>
</div>
<div class="sect3">
<h4 id="_removing_redundant_code_at_the_forms_layer">Removing Redundant Code at the Forms Layer</h4>
<div class="paragraph">
<p>We can get rid of the test for the old save method on the <code>ItemForm</code>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_forms.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line head"><span class="head">--- </span><span class="filename">a/lists/tests/test_forms.py</span></span>
<span class="line head"><span class="head">+++ </span><span class="filename">b/lists/tests/test_forms.py</span></span>
<span class="change"><span class="change">@@</span> -23,14 +23,6 <span class="change">@@</span></span> <span class="keyword">class</span> <span class="class">ItemFormTest</span>(TestCase):

         <span class="predefined-constant">self</span>.assertEqual(form.errors[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>], [EMPTY_ITEM_ERROR])


<span class="line delete"><span class="delete">-</span>    <span class="keyword">def</span> <span class="function">test_form_save_handles_saving_to_a_list</span>(<span class="predefined-constant">self</span>):</span>
<span class="line delete"><span class="delete">-</span>        list_ = List.objects.create()</span>
<span class="line delete"><span class="delete">-</span>        form = ItemForm(data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">do me</span><span class="delimiter">'</span></span>})</span>
<span class="line delete"><span class="delete">-</span>        new_item = form.save(for_list=list_)</span>
<span class="line delete"><span class="delete">-</span>        <span class="predefined-constant">self</span>.assertEqual(new_item, Item.objects.first())</span>
<span class="line delete"><span class="delete">-</span>        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">do me</span><span class="delimiter">'</span></span>)</span>
<span class="line delete"><span class="delete">-</span>        <span class="predefined-constant">self</span>.assertEqual(new_item.list, list_)</span>
<span class="line delete"><span class="delete">-</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And in our actual code, we can get rid of two redundant save methods in
<em>forms.py</em>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/forms.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line head"><span class="head">--- </span><span class="filename">a/lists/forms.py</span></span>
<span class="line head"><span class="head">+++ </span><span class="filename">b/lists/forms.py</span></span>
<span class="change"><span class="change">@@</span> -22,11 +22,6 <span class="change">@@</span></span> <span class="keyword">class</span> <span class="class">ItemForm</span>(forms.models.ModelForm):

         <span class="predefined-constant">self</span>.fields[<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>].error_messages[<span class="string"><span class="delimiter">'</span><span class="content">required</span><span class="delimiter">'</span></span>] = EMPTY_ITEM_ERROR


<span class="line delete"><span class="delete">-</span>    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>, for_list):</span>
<span class="line delete"><span class="delete">-</span>        <span class="predefined-constant">self</span>.instance.list = for_list</span>
<span class="line delete"><span class="delete">-</span>        <span class="keyword">return</span> <span class="predefined">super</span>().save()</span>
<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span></span>

 <span class="keyword">class</span> <span class="class">NewListForm</span>(ItemForm):

<span class="change"><span class="change">@@</span> -52,8 +47,3 <span class="change">@@</span></span> <span class="keyword">class</span> <span class="class">ExistingListItemForm</span>(ItemForm):

             e.error_dict = {<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: [DUPLICATE_ITEM_ERROR]}
             <span class="predefined-constant">self</span>._update_errors(e)
<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span>    <span class="keyword">def</span> <span class="function">save</span>(<span class="predefined-constant">self</span>):</span>
<span class="line delete"><span class="delete">-</span>        <span class="keyword">return</span> forms.models.ModelForm.save(<span class="predefined-constant">self</span>)</span>
<span class="line delete"><span class="delete">-</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_removing_the_old_implementation_of_the_view">Removing the Old Implementation of the View</h4>
<div class="paragraph">
<p>We can now completely remove the old <code>new_list</code> view, and rename <code>new_list2</code> to
<code>new_list</code>:</p>
</div>
<div class="exampleblock sourcecode skipme">
<div class="title">lists/tests/test_views.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line delete"><span class="delete">-</span>from lists.views import new_list<span class="eyecatcher">, new_list2</span></span>
<span class="line insert"><span class="insert">+</span>from lists.views import new_list</span>


 class HomePageTest(TestCase):
<span class="change"><span class="change">@@</span> -75,7 +75,7 <span class="change">@@</span></span> class NewListViewIntegratedTest(TestCase):
         request = HttpRequest()
         request.user = User.objects.create(email='a@b.com')
         request.POST['text'] = 'new list item'
<span class="line delete"><span class="delete">-</span>        new_list<span class="eyecatcher">2</span>(request)</span>
<span class="line insert"><span class="insert">+</span>        new_list(request)</span>
         list_ = List.objects.first()
         self.assertEqual(list_.owner, request.user)

<span class="change"><span class="change">@@</span> -91,21 +91,21 <span class="change">@@</span></span> class NewListViewUnitTest(unittest.TestCase):

     def test_passes_POST_data_to_NewListForm(self, mockNewListForm):
<span class="line delete"><span class="delete">-</span>        new_list<span class="eyecatcher">2</span>(self.request)</span>
<span class="line insert"><span class="insert">+</span>        new_list(self.request)</span>

<span class="line comment">[.. several more]</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock sourcecode dofirst-ch20l045">
<div class="title">lists/urls.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line head"><span class="head">--- </span><span class="filename">a/lists/urls.py</span></span>
<span class="line head"><span class="head">+++ </span><span class="filename">b/lists/urls.py</span></span>
<span class="change"><span class="change">@@</span> -3,7 +3,7 <span class="change">@@</span></span> <span class="keyword">from</span> <span class="include">django.conf.urls</span> <span class="keyword">import</span> <span class="include">url</span>
 <span class="keyword">from</span> <span class="include">lists</span> <span class="keyword">import</span> <span class="include">views</span>

 urlpatterns = [
<span class="line delete"><span class="delete">-</span>    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list<span class="eyecatcher">2</span>, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),</span>
<span class="line insert"><span class="insert">+</span>    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),</span>
     url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
     url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^users/(.+)/$</span><span class="delimiter">'</span></span>, views.my_lists, name=<span class="string"><span class="delimiter">'</span><span class="content">my_lists</span><span class="delimiter">'</span></span>),
 ]</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/views.py (ch20l047)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = NewListForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = form.save(owner=request.user)
        [...]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And a quick check that all the tests still pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
</div>
<div class="sect3 pagebreak-before less_space">
<h4 id="_removing_redundant_code_at_the_forms_layer_2">Removing Redundant Code at the Forms Layer</h4>
<div class="paragraph">
<p>Finally, we have to decide what (if anything) to keep from our integrated test
suite.</p>
</div>
<div class="paragraph">
<p>One option is to throw them all away, and decide that the FTs will pick up any
integration problems.  That&#8217;s perfectly valid.</p>
</div>
<div class="paragraph">
<p>On the other hand, we saw how integrated tests can warn you when you&#8217;ve made
small mistakes in integrating your layers.  We could keep just a couple of
tests around as "sanity checks", to give us a quicker feedback cycle.</p>
</div>
<div class="paragraph">
<p>How about these three:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">lists/tests/test_views.py (ch20l048)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListViewIntegratedTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(Item.objects.count(), <span class="integer">1</span>)
        new_item = Item.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>)


    <span class="keyword">def</span> <span class="function">test_for_invalid_input_doesnt_save_but_shows_errors</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(List.objects.count(), <span class="integer">0</span>)
        <span class="predefined-constant">self</span>.assertContains(response, escape(EMPTY_ITEM_ERROR))


    <span class="keyword">def</span> <span class="function">test_list_owner_is_saved_if_user_is_authenticated</span>(<span class="predefined-constant">self</span>):
        user = User.objects.create(email=<span class="string"><span class="delimiter">'</span><span class="content">a@b.com</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.client.force_login(user)
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">new item</span><span class="delimiter">'</span></span>})
        list_ = List.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(list_.owner, user)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re going to keep any intermediate-level tests at all,  I like these
three because they feel like they&#8217;re doing the most "integration" jobs:  they
test the full stack, from the request down to the actual database, and they
cover the three most important use cases of our view.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusions_when_to_write_isolated_versus_integrated_tests">Conclusions: When to Write Isolated Versus Integrated Tests</h3>
<div class="paragraph">
<p>Django&#8217;s
testing tools make it very easy to quickly put together integrated
tests.  The test runner helpfully creates a fast, in-memory version of your
database and resets it for you in between each test.  The <code>TestCase</code> class
and the test client make it easy to test your views, from checking whether
database objects are modified, confirming that your URL mappings work, and
inspecting the rendering of the templates.  This lets you get started with
testing very easily and get good coverage across your whole stack.</p>
</div>
<div class="paragraph">
<p>On the other hand, these kinds of integrated tests won&#8217;t necessarily deliver
the full benefit that rigorous unit testing and Outside-In TDD are meant to
confer in terms of design.</p>
</div>
<div class="paragraph">
<p>If we look at the example in this chapter, compare the code we had before and
after:</p>
</div>
<div class="listingblock sourcecode skipme">
<div class="title">Before</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = ItemForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = List()
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="predefined">isinstance</span>(request.user, AnonymousUser):
            list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">form</span><span class="delimiter">"</span></span>: form})</code></pre>
</div>
</div>
<div class="listingblock sourcecode skipme">
<div class="title">After</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    form = NewListForm(data=request.POST)
    <span class="keyword">if</span> form.is_valid():
        list_ = form.save(owner=request.user)
        <span class="keyword">return</span> redirect(list_)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">form</span><span class="delimiter">'</span></span>: form})</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we hadn&#8217;t bothered to go down the isolation route, would we have bothered to
refactor the view function?  I know I didn&#8217;t in the first draft of this book.
I&#8217;d like to think I would have "in real life", but it&#8217;s hard to be sure.  But
writing isolated tests does make you very aware of where the complexities in
your code lie.</p>
</div>
<div class="sect3">
<h4 id="_let_complexity_be_your_guide">Let Complexity Be Your Guide</h4>
<div class="paragraph">
<p>I&#8217;d say the point at which isolated tests start to become worth it is to do
with complexity.  The example in this book is extremely simple, so it&#8217;s not
usually been worth it so far.  Even in the example in this chapter, I can
convince myself I didn&#8217;t really <em>need</em> to write those isolated tests.</p>
</div>
<div class="paragraph">
<p>But once an application gains a little more complexity&#8212;&#8203;if it starts growing
any more layers between views and models, if you find yourself writing  helper
methods, or if you&#8217;re writing your own classes, then you will probably gain from writing more
isolated tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="_should_you_do_both">Should You Do Both?</h4>
<div class="paragraph">
<p>We already have our suite of functional tests, which will serve the purpose
of telling us if we ever make any mistakes in integrating the different parts
of our code together.  Writing isolated tests can help us to drive out better
design for our code, and to verify correctness in finer detail.  Would a
middle layer of integration tests serve any additional purpose?</p>
</div>
<div class="paragraph">
<p>I think the answer is potentially yes, if they can provide a faster feedback
cycle, and help you identify more clearly what integration problems you suffer
from&#8212;&#8203;their tracebacks may provide you with better debug information than you
would get from a functional test, for example.</p>
</div>
<div class="paragraph">
<p>There may even be a case for building them as a separate test suite&#8212;&#8203;you
could have one suite of fast, isolated unit tests that don&#8217;t even use
<code>manage.py</code>, because they don&#8217;t need any of the database cleanup and teardown
that the Django test runner gives you, and then the intermediate layer that
uses Django, and finally the functional tests layer that, say, talks to a
staging server.  It may be worth it if each layer delivers incremental
benefits.</p>
</div>
<div class="paragraph">
<p>It&#8217;s a judgement call.  I hope that, by going through this chapter, I&#8217;ve given
you a feel for what the trade-offs are. There&#8217;s more discussion on this in
<a href="/book/chapter_hot_lava.html">[chapter_hot_lava]</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_onwards">Onwards!</h4>
<div class="paragraph">
<p>We&#8217;re happy with our new version, so let&#8217;s bring it across to master:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git add .</strong>
$ <strong>git commit -m "add list owners via forms. more isolated tests"</strong>
$ <strong>git checkout master</strong>
$ <strong>git checkout -b master-noforms-noisolation-bak</strong> # optional backup
$ <strong>git checkout master</strong>
$ <strong>git reset --hard more-isolation</strong>  # reset master to our branch.</pre>
</div>
</div>
<div class="paragraph">
<p>In the meantime&#8212;&#8203;those FTs are taking an annoyingly long time to run.  I
wonder if there&#8217;s something we can do about that?</p>
</div>
<div class="sidebarblock pagebreak-before less_space">
<div class="content">
<div class="title">On the Pros and Cons of Different Types of Tests, <br>and Decoupling ORM Code</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Functional tests</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Provide
the best guarantee that your application really works correctly,
    from the point of view of the user</p>
</li>
<li>
<p>But: it&#8217;s a slower feedback cycle</p>
</li>
<li>
<p>And they don&#8217;t necessarily help you write clean code</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Integrated tests (reliant on, for example, the ORM or the Django Test Client)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Are
quick to write</p>
</li>
<li>
<p>Are easy to understand</p>
</li>
<li>
<p>Will warn you of any integration issues</p>
</li>
<li>
<p>But: may not always drive good design (that&#8217;s up to you!)</p>
</li>
<li>
<p>And are usually slower than isolated tests</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Isolated ("mocky") tests</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Involve
the most hard work</p>
</li>
<li>
<p>Can be harder to read and understand</p>
</li>
<li>
<p>But: are the best ones for guiding you towards better design</p>
</li>
<li>
<p>And run the fastest</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Decoupling our application from ORM code</dt>
<dd>
<p>    One
of the consequences of striving to write isolated tests is that we
    find ourselves forced to remove ORM code from places like views and forms,
    by hiding it behind helper functions or methods.  This can be beneficial in
    terms of decoupling your application from the ORM, but also just because it
    makes your code more readable. As with all things, it&#8217;s a judgement call as
    to whether the additional effort is worth it in particular circumstances.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. It could easily just be a standalone function, but hanging it on the model class is a nice way to keep track of where it lives, and gives a bit more of a hint as to what it will do.
</div>
</div>
<div id="footer">
<div id="footer-text">
License: Creative Commons <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode">CC-BY-NC-ND</a>. Last updated: 2018-06-12 14:14:52 BST
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = 'chapter_purist_unit_tests';
    };
    
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//obeythetestinggoat.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>