<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Working Incrementally</title>
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_working_incrementally">Working Incrementally</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all" style="float: right;">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">Chapter info</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shortname:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chapter_working_incrementally</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
2017-03-13: Book upgraded to Python 3.6 and Django 1.11 beta.
    Before that, there was a big upgrade to Selenium 3 on 2017-01-30. More
    info <a href="https://www.obeythetestinggoat.com/latest-release-the-last-big-one-python-36-django-111-beta.html">on the blog</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s address our real problem, which is that our design only allows for
one global list.  In this chapter I&#8217;ll demonstrate a critical TDD technique:
how to adapt existing code using an incremental, step-by-step process which
takes you from working state to working state. Testing Goat, not Refactoring
Cat.</p>
</div>
<div class="sect2">
<h3 id="_small_design_when_necessary">Small Design When Necessary</h3>
<div class="paragraph">
<p>Let&#8217;s have a think about how we want support for multiple lists to
work.  Currently the FT (which is the closest we have to a design document)
says this:</p>
</div>
<div class="listingblock sourcecode currentcontents dofirst-ch07l000">
<div class="title">functional_tests/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="comment"># Edith wonders whether the site will remember her list. Then she sees</span>
    <span class="comment"># that the site has generated a unique URL for her -- there is some</span>
    <span class="comment"># explanatory text to that effect.</span>
    <span class="predefined-constant">self</span>.fail(<span class="string"><span class="delimiter">'</span><span class="content">Finish the test!</span><span class="delimiter">'</span></span>)

    <span class="comment"># She visits that URL - her to-do list is still there.</span>

    <span class="comment"># Satisfied, she goes back to sleep</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But really we want to expand on this, by saying that different users
don&#8217;t see each other&#8217;s lists, and each get their own URL as a way of
going back to their saved lists.  What might a new design look like?</p>
</div>
<div class="sect3">
<h4 id="_not_big_design_up_front">Not Big Design Up Front</h4>
<div class="paragraph">
<p>

TDD is closely associated with the agile movement in software development,
which includes a reaction against <em>Big Design Up Front</em> the
traditional software engineering practice whereby, after a lengthy requirements
gathering exercise, there is an equally lengthy design stage where the
software is planned out on paper. The agile philosophy is that you learn more
from solving problems in practice than in theory, especially when you confront
your application with real users as soon as possible. Instead of a long
up-front design phase, we try and put a <em>minimum viable application</em> out
there early, and let the design evolve gradually based on feedback from
real-world usage.</p>
</div>
<div class="paragraph">
<p>
But that doesn&#8217;t mean that thinking about design is outright banned! In the
last chapter we saw how just blundering ahead without thinking can <em>eventually</em>
get us to the right answer, but often a little thinking about design can help
us get there faster. So, let&#8217;s think about our minimum viable lists app, and
what kind of design we&#8217;ll need to deliver it.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We want each user to be able to store their own list&#8212;&#8203;at least one, for now.</p>
</li>
<li>
<p>A list is made up of several items, whose primary attribute is a bit of
descriptive text.</p>
</li>
<li>
<p>We need to save lists from one visit to the next.  For now, we can give
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To deliver the "for now" items, it sounds like we&#8217;re going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.</p>
</div>
</div>
<div class="sect3">
<h4 id="_yagni">YAGNI!</h4>
<div class="paragraph">
<p>
Once you start thinking about design, it can be hard to stop. All sorts of
other thoughts are occurring to us&#8212;&#8203;we might want to give each list
a name or title, we might want to recognise users using usernames and
passwords, we might want to add a longer notes field as well as short
descriptions to our list, we might want to store some kind of ordering, and so
on.  But we obey another tenet of the agile gospel:  "YAGNI" (pronounced
yag-knee), which stands for "You aint gonna need it!"  As software
developers, we have fun creating things, and sometimes it&#8217;s hard to resist
the urge to build things just because an idea occurred to us and we <em>might</em>
need it.  The trouble is that more often than not, no matter how cool the idea
was, you <em>won&#8217;t</em> end up using it. Instead you have a load of unused code,
adding to the complexity of your application. YAGNI is the mantra we use to
resist our overenthusiastic creative urges.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rest_ish">REST (ish)</h4>
<div class="paragraph">
<p>We have an idea of the data structure we want&#8212;&#8203;the Model part of
Model-View-Controller (MVC).  What about the View and Controller parts?
How should the user interact with Lists and their Items using a web browser?</p>
</div>
<div class="paragraph">
<p>
Representational State Transfer (REST) is an approach to web design that&#8217;s
usually used to guide the design of web-based APIs. When designing a
user-facing site, it&#8217;s not possible to stick <em>strictly</em> to the REST rules,
but they still provide some useful inspiration (skip ahead to
<a href="/book/appendix_rest_api.html">[appendix_rest_api]</a> if you want to see a real REST API).</p>
</div>
<div class="paragraph">
<p>REST suggests that we have a URL structure that matches our data structure,
in this case lists and list items.  Each list can have its own URL:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>    /lists/&lt;list identifier&gt;/</pre>
</div>
</div>
<div class="paragraph">
<p>That will fulfill the requirement we&#8217;ve specified in our FT. To view a list, we
use a GET request (a normal browser visit to the page).</p>
</div>
<div class="paragraph">
<p>To create a brand new list, we&#8217;ll have a special URL that accepts POST
requests:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>    /lists/new</pre>
</div>
</div>
<div class="paragraph">
<p>To add a new item to an existing list, we&#8217;ll have a separate URL, to which
we can send POST requests:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>    /lists/&lt;list identifier&gt;/add_item</pre>
</div>
</div>
<div class="paragraph">
<p>(Again, we&#8217;re not trying to perfectly follow the rules of REST, which would
use a PUT request here&#8212;&#8203;we&#8217;re just using REST for inspiration. Apart from
anything else, you can&#8217;t use PUT in a standard HTML form.)</p>
</div>
<div class="paragraph">
<p>In summary, our scratchpad for this chapter looks something like this:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Adjust model so that items are associated with different lists</em></p>
</li>
<li>
<p><em>Add unique URLs for each list</em></p>
</li>
<li>
<p><em>Add a URL for creating a new list via POST</em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_the_new_design_incrementally_using_tdd">Implementing the New Design Incrementally using TDD</h3>
<div class="paragraph">
<p>

How do we use TDD to implement the new design? Let&#8217;s take another look at
the flowchart for the TDD process in <a href="#TDD-double-loop">The TDD process with functional and unit tests</a>.</p>
</div>
<div class="paragraph">
<p>At the top level, we&#8217;re going to use a combination of adding new functionality
(by adding a new FT and writing new application code), and refactoring our
application&#8212;&#8203;i.e., rewriting some of the existing implementation so that it
delivers the same functionality to the user but using aspects of our new
design. We&#8217;ll be able to use the existing functional test to verify we don&#8217;t
break what already works, and the new functional test to drive the new
features.</p>
</div>
<div class="paragraph">
<p>At the unit test level, we&#8217;ll be adding new tests or modifying existing ones to
test for the changes we want, and we&#8217;ll be able to similarly use the unit tests
we don&#8217;t touch to help make sure we don&#8217;t break anything in the process.</p>
</div>
<div id="TDD-double-loop" class="imageblock">
<div class="content">
<img src="images/twdp_0601.png" alt="A flowchart showing functional tests as the overall cycle, and unit tests helping to code. Tests passing and failing are marked as green and red respectively.">
</div>
<div class="title">Figure 1. The TDD process with functional and unit tests</div>
</div>
</div>
<div class="sect2">
<h3 id="_ensuring_we_have_a_regression_test">Ensuring we have a regression test</h3>
<div class="paragraph">
<p>Let&#8217;s translate our scratchpad into a new functional test method, which
introduces a second user and checks that their to-do list is separate from
Edith&#8217;s.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start out very similarly to the first, Edith adds a first item to
create a to-do list, but we introduce our first new assertion:  Edith&#8217;s
list should live at its own, unique URL:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/tests.py (ch07l005)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">test_can_start_a_list_for_one_user</span>(<span class="predefined-constant">self</span>):
    <span class="comment"># Edith has heard about a cool new online to-do app. She goes</span>
    [...]
    <span class="comment"># The page updates again, and now shows both items on her list</span>
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">2: Use peacock feathers to make a fly</span><span class="delimiter">'</span></span>)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">1: Buy peacock feathers</span><span class="delimiter">'</span></span>)

    <span class="comment"># Satisfied, she goes back to sleep</span>


<span class="keyword">def</span> <span class="function">test_multiple_users_can_start_lists_at_different_urls</span>(<span class="predefined-constant">self</span>):
    <span class="comment"># Edith start a new todo list</span>
    <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.live_server_url)
    inputbox = <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>)
    inputbox.send_keys(<span class="string"><span class="delimiter">'</span><span class="content">Buy peacock feathers</span><span class="delimiter">'</span></span>)
    inputbox.send_keys(Keys.ENTER)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">1: Buy peacock feathers</span><span class="delimiter">'</span></span>)

    <span class="comment"># She notices that her list has a unique URL</span>
    edith_list_url = <span class="predefined-constant">self</span>.browser.current_url
    <span class="predefined-constant">self</span>.assertRegex(edith_list_url, <span class="string"><span class="delimiter">'</span><span class="content">/lists/.+</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>assertRegex</code> is a helper function from <code>unittest</code> that checks
whether a string matches a regular expression. We use it to check that our
new REST-ish design has been implemented. Find out more in the

<a href="http://docs.python.org/3/library/unittest.html"><code>unittest</code> documentation</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next we imagine a new user coming along. We want to check that they don&#8217;t see
any of Edith&#8217;s items when they visit the home page, and that they get their own
unique URL for their list.</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/tests.py (ch07l006)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    [...]
    <span class="predefined-constant">self</span>.assertRegex(edith_list_url, <span class="string"><span class="delimiter">'</span><span class="content">/lists/.+</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="comment"># Now a new user, Francis, comes along to the site.</span>

    <span class="comment">## We use a new browser session to make sure that no information</span>
    <span class="comment">## of Edith's is coming through from cookies etc</span>
    <span class="predefined-constant">self</span>.browser.quit()
    <span class="predefined-constant">self</span>.browser = webdriver.Firefox()

    <span class="comment"># Francis visits the home page.  There is no sign of Edith's</span>
    <span class="comment"># list</span>
    <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.live_server_url)
    page_text = <span class="predefined-constant">self</span>.browser.find_element_by_tag_name(<span class="string"><span class="delimiter">'</span><span class="content">body</span><span class="delimiter">'</span></span>).text
    <span class="predefined-constant">self</span>.assertNotIn(<span class="string"><span class="delimiter">'</span><span class="content">Buy peacock feathers</span><span class="delimiter">'</span></span>, page_text)
    <span class="predefined-constant">self</span>.assertNotIn(<span class="string"><span class="delimiter">'</span><span class="content">make a fly</span><span class="delimiter">'</span></span>, page_text)

    <span class="comment"># Francis starts a new list by entering a new item. He</span>
    <span class="comment"># is less interesting than Edith...</span>
    inputbox = <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>)
    inputbox.send_keys(<span class="string"><span class="delimiter">'</span><span class="content">Buy milk</span><span class="delimiter">'</span></span>)
    inputbox.send_keys(Keys.ENTER)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">1: Buy milk</span><span class="delimiter">'</span></span>)

    <span class="comment"># Francis gets his own unique URL</span>
    francis_list_url = <span class="predefined-constant">self</span>.browser.current_url
    <span class="predefined-constant">self</span>.assertRegex(francis_list_url, <span class="string"><span class="delimiter">'</span><span class="content">/lists/.+</span><span class="delimiter">'</span></span>)
    <span class="predefined-constant">self</span>.assertNotEqual(francis_list_url, edith_list_url)

    <span class="comment"># Again, there is no trace of Edith's list</span>
    page_text = <span class="predefined-constant">self</span>.browser.find_element_by_tag_name(<span class="string"><span class="delimiter">'</span><span class="content">body</span><span class="delimiter">'</span></span>).text
    <span class="predefined-constant">self</span>.assertNotIn(<span class="string"><span class="delimiter">'</span><span class="content">Buy peacock feathers</span><span class="delimiter">'</span></span>, page_text)
    <span class="predefined-constant">self</span>.assertIn(<span class="string"><span class="delimiter">'</span><span class="content">Buy milk</span><span class="delimiter">'</span></span>, page_text)

    <span class="comment"># Satisfied, they both go back to sleep</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>I&#8217;m using the convention of double-hashes (<code>##</code>) to indicate
"meta-comments"&#8212;comments about <em>how</em> the test is working and why&#8212;&#8203;so
that we can distinguish them from regular comments in FTs which explain the
User Story. They&#8217;re a message to our future selves, which might otherwise
be wondering why the heck we&#8217;re quitting the browser and starting a new
one&#8230;&#8203;

</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Other than that, the new test is fairly self-explanatory. Let&#8217;s see how we do
when we run our FTs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
.F
======================================================================
FAIL: test_multiple_users_can_start_lists_at_different_urls
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/tests.py", line 83, in
test_multiple_users_can_start_lists_at_different_urls
    self.assertRegex(edith_list_url, '/lists/.+')
AssertionError: Regex didn't match: '/lists/.+' not found in
'http://localhost:8081/'

 ---------------------------------------------------------------------
Ran 2 tests in 5.786s

FAILED (failures=1)</pre>
</div>
</div>
<div class="paragraph">
<p>Good, our first test still passes, and the second one fails where we might
expect.  Let&#8217;s do a commit, and then go and build some new models and views:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -a</strong></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iterating_towards_the_new_design">Iterating Towards the New Design</h3>
<div class="paragraph">
<p>

Being all excited about our new design, I had an overwhelming urge to dive in
at this point and start changing <em>models.py</em>, which would have broken half the
unit tests, and then pile in and change almost every single line of code, all
in one go.  That&#8217;s a natural urge, and TDD, as a discipline, is a constant
fight against it. Obey the Testing Goat, not Refactoring Cat!  We don&#8217;t need to
implement our new, shiny design in a single big bang. Let&#8217;s make small changes
that take us from a working state to a working state, with our design guiding
us gently at each stage.</p>
</div>
<div class="paragraph">
<p>There are four items on our to-do list. The FT, with its <code>Regexp didn't
match</code>, is telling us that the second item&#8212;&#8203;giving lists their own URL and
identifier&#8212;&#8203;is the one we should work on next. Let&#8217;s have a go at fixing
that, and only that.</p>
</div>
<div class="paragraph">
<p>The URL comes from the redirect after POST.  In <em>lists/tests.py</em>, find
<code>test_redirects_after_POST</code>, and change the expected redirect
location:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="predefined-constant">self</span>.assertEqual(response.status_code, <span class="integer">302</span>)
<span class="predefined-constant">self</span>.assertEqual(response[<span class="string"><span class="delimiter">'</span><span class="content">location</span><span class="delimiter">'</span></span>], <span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Does that seem slightly strange?  Clearly, <em>/lists/the-only-list-in-the-world</em>
isn&#8217;t a URL that&#8217;s going to feature in the final design of our application. But
we&#8217;re committed to changing one thing at a time.  While our application only
supports one list, this is the only URL that makes sense.  We&#8217;re still moving
forwards, in that we&#8217;ll have a different URL for our list and our home page,
which is a step along the way to a more REST-ful design. Later, when we have
multiple lists, it will be easy to change.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Another way of thinking about it is as a problem-solving technique: our
    new URL design is currently not implemented, so it works for 0 items.
    Ultimately, we want to solve for <em>n</em> items, but solving for 1 item is a
    good step along the way.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Running the unit tests gives us an expected fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
AssertionError: '/' != '/lists/the-only-list-in-the-world/'</pre>
</div>
</div>
<div class="paragraph">
<p>We can go adjust our <code>home_page</code> view in <em>lists/views.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">home_page</span>(request):
    <span class="keyword">if</span> request.method == <span class="string"><span class="delimiter">'</span><span class="content">POST</span><span class="delimiter">'</span></span>:
        Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>])
        <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)

    items = Item.objects.all()
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">items</span><span class="delimiter">'</span></span>: items})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, that will now totally break the functional tests, because there is
no such URL on our site yet.  Sure enough, if you run them, you&#8217;ll find they
fail just after trying to submit the first item, saying that they can&#8217;t find
the list table; it&#8217;s because URL <em>/the-only-list-in-the-world/</em> doesn&#8217;t exist
yet!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  File "/.../superlists/functional_tests/tests.py", line 57, in
test_can_start_a_list_for_one_user
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]

[...]

  File "/.../superlists/functional_tests/tests.py", line 79, in
test_multiple_users_can_start_lists_at_different_urls
    self.wait_for_row_in_list_table('1: Buy peacock feathers')
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]</pre>
</div>
</div>
<div class="paragraph">
<p>Not only is our new test failing, but the old one is too.  That tells
us we&#8217;ve introduce a <em>regression</em>.  Let&#8217;s try and get back to a working
state as quickly as possible by building a URL for our one and only list.</p>
</div>
</div>
<div class="sect2">
<h3 id="_taking_a_first_self_contained_step_one_new_url">Taking a first, self-contained step: one new URL</h3>
<div class="paragraph">
<p>Open up <em>lists/tests.py</em>, and add a new test class called <code>ListViewTest</code>.  Then
copy the method called <code>test_displays_all_list_items</code> across from
<code>HomePageTest</code> into our new class, rename it, and adapt it slightly:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py (ch07l009)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_displays_all_items</span>(<span class="predefined-constant">self</span>):
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 1</span><span class="delimiter">'</span></span>)
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 2</span><span class="delimiter">'</span></span>)

        response = <span class="predefined-constant">self</span>.client.get(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)

        <span class="predefined-constant">self</span>.assertContains(response, <span class="string"><span class="delimiter">'</span><span class="content">itemey 1</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="predefined-constant">self</span>.assertContains(response, <span class="string"><span class="delimiter">'</span><span class="content">itemey 2</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here&#8217;s a new helper method: instead of using the slightly annoying
<code>assertIn</code>/<code>response.content.decode()</code> dance, Django provides the
<code>assertContains</code> method which knows how to deal with responses and the
bytes of their content.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s try running this test now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertContains(response, 'itemey 1')
[...]
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a nice side-effect of using <code>assertContains</code>: it tells us straight
away that the test is failing because our new URL doesn&#8217;t exist yet, and
is returning a 404.</p>
</div>
<div class="sect3">
<h4 id="_a_new_url">A New URL</h4>
<div class="paragraph">
<p>

Our singleton list URL doesn&#8217;t exist yet.  We fix that in <em>superlists/urls.py</em>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Watch out for trailing slashes in URLs, both here in the tests and in
    <em>urls.py</em>. They&#8217;re a common source of bugs.
</td>
</tr>
</table>
</div>
<div class="listingblock sourcecode small-code">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^$</span><span class="delimiter">'</span></span>, views.home_page, name=<span class="string"><span class="delimiter">'</span><span class="content">home</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/the-only-list-in-the-world/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running the tests again, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AttributeError: module 'lists.views' has no attribute 'view_list'</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_new_view_function">A New View Function</h4>
<div class="paragraph">
<p>

Nicely self-explanatory.  Let&#8217;s create a dummy view function in
<em>lists/views.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request):
    <span class="keyword">pass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ValueError: The view lists.views.view_list didn't return an HttpResponse
object. It returned None instead.

[...]
FAILED (errors=1)</pre>
</div>
</div>
<div class="paragraph">
<p>Down to just one failure, and it&#8217;s pointing us in the right direction. Let&#8217;s
copy the two last lines from the <code>home_page</code> view and see if they&#8217;ll do the
trick:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request):
    items = Item.objects.all()
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">items</span><span class="delimiter">'</span></span>: items})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rerun the unit tests and they should pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 7 tests in 0.016s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s try the FTs again and see what they tell us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_can_start_a_list_for_one_user
[...]
  File "/.../superlists/functional_tests/tests.py", line 67, in
test_can_start_a_list_for_one_user
[...]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']

FAIL: test_multiple_users_can_start_lists_at_different_urls
[...]
AssertionError: 'Buy peacock feathers' unexpectedly found in 'Your To-Do
list\n1: Buy peacock feathers'
[...]</pre>
</div>
</div>
<div class="paragraph">
<p>Both of them are getting a little further than they were before, but they&#8217;re
still failing.  It would be nice to get back to a working state and get that
first one passing again.  What&#8217;s it trying to tell us?</p>
</div>
<div class="paragraph">
<p>It&#8217;s failing when we try to add the second item.  We have to put our debugging
hats on here.  We know the home page is working, because the test has got all
the way down to line 67 in the FT, so we&#8217;ve at least added a first item.  And
our unit tests are all passing, so we&#8217;re pretty sure the URLs and views are
doing what they should&#8201;&#8212;&#8201;the home page displays the right template, and
can handle POST requests, and the <em>only-list-in-the-world</em> view knows how
to display all items&#8230;&#8203;  But it doesn&#8217;t know how to handle POST requests. Ah,
that gives us a clue.</p>
</div>
<div class="paragraph">
<p>A second clue is the rule of thumb that, when all the unit tests are passing
but the functional tests aren&#8217;t, it&#8217;s often pointing at a problem that&#8217;s not
covered by the unit tests, and in our case, that&#8217;s often a template problem.</p>
</div>
<div class="paragraph">
<p>The answer is that our <em>home.html</em> input form currently doesn&#8217;t specify an
explicit URL to POST to.</p>
</div>
<div class="listingblock sourcecode currentcontents">
<div class="title">lists/templates/home.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">        <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the browser sends the POST data back to the same URL it&#8217;s currently
on.  When we&#8217;re on the home page that works fine, but when we&#8217;re on our
<em>only-list-in-the-world</em> page, it doesn&#8217;t.</p>
</div>
<div class="paragraph">
<p>Now we could dive in and add POST request handling to our new view, but that
would involve writing a bunch more tests and code, and at this point we&#8217;d like
to get back to a working state as quickly as possible.  Actually the quickest
thing we can do to get things fixed is to just use the existing home page view,
which already works, for all POST requests:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/home.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">        <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">/</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Try that, and we&#8217;ll see our FTs get back to a happier place:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_multiple_users_can_start_lists_at_different_urls
[...]
AssertionError: 'Buy peacock feathers' unexpectedly found in 'Your To-Do
list\n1: Buy peacock feathers'

Ran 2 tests in 8.541s
FAILED (failures=1)</pre>
</div>
</div>
<div class="paragraph">
<p>Our original test passes once again, so we know we&#8217;re back to a working state.
The new functionality may not be working yet, but at least the old stuff works
as well as it used to.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_green_refactor">Green? Refactor</h3>
<div class="paragraph">
<p>

Time for a little tidying up.</p>
</div>
<div class="paragraph">
<p>In the <em>Red/Green/Refactor</em> dance, we&#8217;ve arrived at green, so we should see
what needs a refactor.  We now have two views, one for the home page, and one
for an individual list.  Both are currently using the same template, and
passing it all the list items currently in the database.  If we look through
our unit test methods, we can see some stuff we probably want to change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>grep -E "class|def" lists/tests.py</strong>
class HomePageTest(TestCase):
    def test_uses_home_template(self):
    def test_displays_all_list_items(self):
    def test_can_save_a_POST_request(self):
    def test_redirects_after_POST(self):
    def test_only_saves_items_when_necessary(self):
class ListViewTest(TestCase):
    def test_displays_all_items(self):
class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):</pre>
</div>
</div>
<div class="paragraph">
<p>We can definitely delete the <code>test_displays_all_list_items</code> method from
<code>HomePageTest</code>, it&#8217;s no longer needed.  If you run <strong><code>manage.py test lists</code></strong>
now, it should say it ran 6 tests instead of 7:</p>
</div>
<div class="listingblock dofirst-ch07l012">
<div class="content">
<pre>Ran 6 tests in 0.016s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Next, since we don&#8217;t actually need the home page template to display all list
items any more; it should just show a single input box inviting you to start a
new list.</p>
</div>
</div>
<div class="sect2">
<h3 id="_another_small_step_a_separate_template_for_viewing_lists">Another Small Step: A Separate Template for Viewing Lists</h3>
<div class="paragraph">
<p>

Since the home page and the list view are now quite distinct pages,
they should be using different HTML templates; <em>home.html</em> can have the
single input box, whereas a new template, <em>list.html</em>, can take care
of showing the table of existing items.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add a new test to check that it&#8217;s using a different template:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_uses_list_template</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.get(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertTemplateUsed(response, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>)


    <span class="keyword">def</span> <span class="function">test_displays_all_items</span>(<span class="predefined-constant">self</span>):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>
<code>assertTemplateUsed</code> is one of the more useful functions that the Django test
client gives us.  Let&#8217;s see what it says:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: False is not true : Template 'list.html' was not a template
used to render the response. Actual template(s) used: home.html</pre>
</div>
</div>
<div class="paragraph">
<p>Great!  Let&#8217;s change the view:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request):
    items = Item.objects.all()
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">items</span><span class="delimiter">'</span></span>: items})</code></pre>
</div>
</div>
<div class="paragraph">
<p>But, obviously, that template doesn&#8217;t exist yet. If we run the unit tests, we
get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>django.template.exceptions.TemplateDoesNotExist: list.html</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s create a new file at <em>lists/templates/list.html</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>touch lists/templates/list.html</strong></pre>
</div>
</div>
<div class="paragraph">
<p>A blank template, which gives us this error&#8212;&#8203;good to know the tests are
there to make sure we fill it in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: False is not true : Couldn't find 'itemey 1' in response</pre>
</div>
</div>
<div class="paragraph">
<p>The template for an individual list will reuse quite a lot of the stuff
we currently have in <em>home.html</em>, so we can start by just copying that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>cp lists/templates/home.html lists/templates/list.html</strong></pre>
</div>
</div>
<div class="paragraph">
<p>That gets the tests back to passing (green).  Now let&#8217;s do a little more
tidying up (refactoring).  We said the home page doesn&#8217;t need to list items, it
only needs the new list input field, so we can remove some lines from
<em>lists/templates/home.html</em>, and maybe slightly tweak the <code>h1</code> to say "Start a
new To-Do list":</p>
</div>
<div class="listingblock sourcecode small-code">
<div class="title">lists/templates/home.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html"><span class="tag">&lt;body&gt;</span>
  <span class="tag">&lt;h1&gt;</span>Start a new To-Do list<span class="tag">&lt;/h1&gt;</span>
  <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;input</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">"</span><span class="content">item_text</span><span class="delimiter">"</span></span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">id_new_item</span><span class="delimiter">"</span></span> <span class="attribute-name">placeholder</span>=<span class="string"><span class="delimiter">"</span><span class="content">Enter a to-do item</span><span class="delimiter">"</span></span> <span class="tag">/&gt;</span>
    {% csrf_token %}
  <span class="tag">&lt;/form&gt;</span>
<span class="tag">&lt;/body&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We rerun the unit tests to check that hasn&#8217;t broken anything&#8212;&#8203;good&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>There&#8217;s actually no need to pass all the items to the <em>home.html</em> template in
our <code>home_page</code> view, so we can simplify that:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">home_page</span>(request):
    <span class="keyword">if</span> request.method == <span class="string"><span class="delimiter">'</span><span class="content">POST</span><span class="delimiter">'</span></span>:
        Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>])
        <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rerun the unit tests once more; they still pass. Time to run the functional
tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']</pre>
</div>
</div>
<div class="paragraph">
<p>Not bad!  Our regression test (the first FT) is passing, and our new test
is now getting slightly further forwards&#8201;&#8212;&#8201;it&#8217;s telling us that Francis
isn&#8217;t getting his own list page (because he still sees some of Edith&#8217;s
list items.)</p>
</div>
<div class="paragraph">
<p>It may feel like we haven&#8217;t made much headway since, functionally, the site
still behaves almost exactly like it did when we started the chapter, but this
really is progress. We&#8217;ve started on the road to our new design, and we&#8217;ve
implemented a number of stepping stones <em>without making anything worse than it
was before</em>.  Let&#8217;s commit our progress so far:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git status</strong> # should show 4 changed files and 1 new file, list.html
$ <strong>git add lists/templates/list.html</strong>
$ <strong>git diff</strong> # should show we've simplified home.html,
           # moved one test to a new class in lists/tests.py added a new view
           # in views.py, and simplified home_page and made one addition to
           # urls.py
$ <strong>git commit -a</strong> # add a message summarising the above, maybe something like
                # "new URL, view and template to display lists"</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_third_small_step_a_url_for_adding_list_items">A Third Small Step: a URL for Adding List Items</h3>
<div class="paragraph">
<p>Where are we with our own to-do list?</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Adjust model so that items are associated with different lists</em></p>
</li>
<li>
<p><em>Add unique URLs for each list</em>  &#8592;- &#8230;&#8203;</p>
</li>
<li>
<p><em>Add a URL for creating a new list via POST</em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve <em>sort of</em> made progress on the third item, even if there&#8217;s still only one
list in the world. Item 2 is a bit scary.  Can we do something about items 4 or
5?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a new URL for adding new list items.  If nothing else, it&#8217;ll
simplify the home page view.</p>
</div>
<div class="sect3">
<h4 id="_a_test_class_for_new_list_creation">A Test Class for New List Creation</h4>
<div class="paragraph">
<p>
Open up <em>lists/tests.py</em>, and <em>move</em> the
<code>test_can_save_a_POST_request</code> and <code>test_redirects_after_POST</code> methods into a
new class, then change the URL they POST to:</p>
</div>
<div class="listingblock sourcecode small-code">
<div class="title">lists/tests.py (ch07l021-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(Item.objects.count(), <span class="integer">1</span>)
        new_item = Item.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>)


    <span class="keyword">def</span> <span class="function">test_redirects_after_POST</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(response.status_code, <span class="integer">302</span>)
        <span class="predefined-constant">self</span>.assertEqual(response[<span class="string"><span class="delimiter">'</span><span class="content">location</span><span class="delimiter">'</span></span>], <span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This is another place to pay attention to trailing slashes, incidentally.
    It&#8217;s <code>/new</code>, with no trailing slash.  The convention I&#8217;m using is that URLs
    without a trailing slash are "action" URLs which modify the database.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While we&#8217;re at it, let&#8217;s learn a new Django Test Client method, <code>assertRedirects</code>:</p>
</div>
<div class="listingblock sourcecode small-code">
<div class="title">lists/tests.py (ch07l021-2)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_redirects_after_POST</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertRedirects(response, <span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s not much to it, but it just nicely replaces two asserts with a single
one&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Try running that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
[...]
    self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
[...]
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)</pre>
</div>
</div>
<div class="paragraph">
<p>The first failure tells us we&#8217;re not saving a new item to the database, and the
second says that, instead of returning a 302 redirect, our view is returning
a 404. That&#8217;s because we haven&#8217;t built a URL for <em>/lists/new</em>, so the
<code>client.post</code> is just getting a "not found" response.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do you remember how we split this out into two tests in the last chapter?
    If we only had one test that checked both the saving and the redirect, it
    would have failed on the <code>0 != 1</code> failure, which would have been much
    harder to debug.  Ask me how I know this.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_a_url_and_view_for_new_list_creation">A URL and View for New List Creation</h4>
<div class="paragraph">
<p>



Let&#8217;s build our new URL now:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^$</span><span class="delimiter">'</span></span>, views.home_page, name=<span class="string"><span class="delimiter">'</span><span class="content">home</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/the-only-list-in-the-world/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we get a <code>no attribute 'new_list'</code>, so let&#8217;s fix that, in
<em>lists/views.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch07l023-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    <span class="keyword">pass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we get "The view lists.views.new_list didn&#8217;t return an HttpResponse
object".  (This is getting rather familiar!)  We could return a raw
<code>HttpResponse</code>, but since we know we&#8217;ll need a redirect, let&#8217;s borrow a line
from <code>home_page</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch07l023-2)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1</pre>
</div>
</div>
<div class="paragraph">
<p>Seems reasonably straightforward. We borrow another line from <code>home_page</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch07l023-3)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>])
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And everything now passes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 7 tests in 0.030s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>And the FTs show me that I&#8217;m back to the working state:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[...]
AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
Ran 2 tests in 8.972s
FAILED (failures=1)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_removing_now_redundant_code_and_tests">Removing Now-Redundant Code and Tests</h4>
<div class="paragraph">
<p>
We&#8217;re looking good. Since our new views are now doing most of the work that
<code>home_page</code> used to do, we should be able to massively simplify it. Can we
remove the whole <code>if request.method == 'POST'</code> section, for example?</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">home_page</span>(request):
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yep!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
<div class="paragraph">
<p>And while we&#8217;re at it, we can remove the now-redundant
<code>test_only_saves_items_when_necessary</code> test too!</p>
</div>
<div class="paragraph">
<p>Doesn&#8217;t that feel good?  The view functions are looking much simpler. We rerun
the tests to make sure&#8230;&#8203;</p>
</div>
<div class="listingblock dofirst-ch07l025">
<div class="content">
<pre>Ran 6 tests in 0.016s
OK</pre>
</div>
</div>
<div class="paragraph">
<p>and the FTs?</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_regression_pointing_our_forms_at_the_new_url">A regression! Pointing Our Forms at the New URL</h4>
<div class="paragraph">
<p>Oops:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: test_can_start_a_list_for_one_user
[...]
  File "/.../superlists/functional_tests/tests.py", line 57, in
test_can_start_a_list_for_one_user
    self.wait_for_row_in_list_table('1: Buy peacock feathers')
  File "/.../superlists/functional_tests/tests.py", line 23, in
wait_for_row_in_list_table
    table = self.browser.find_element_by_id('id_list_table')
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]

ERROR: test_multiple_users_can_start_lists_at_different_urls
[...]
  File "/.../superlists/functional_tests/tests.py", line 79, in
test_multiple_users_can_start_lists_at_different_urls
    self.wait_for_row_in_list_table('1: Buy peacock feathers')
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]
[...]

Ran 2 tests in 11.592s
FAILED (errors=2)</pre>
</div>
</div>
<div class="paragraph">
<p>


It&#8217;s because our forms are still pointing to the old URL. In <em>both</em> <em>home.html</em>
and <em>lists.html</em>, let&#8217;s change them to:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/home.html, lists/templates/list.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">    <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">/lists/new</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And that should get us back to working again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
[...]
FAILED (failures=1)</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s another nicely self-contained commit, in that we&#8217;ve made a bunch
of changes to our URLs, our <em>views.py</em> is looking much neater and tidier, and
we&#8217;re sure the application is still working as well as it did before.  We&#8217;re
getting good at this working-state-to-working-state malarkey!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git status</strong> # 5 changed files
$ <strong>git diff</strong> # URLs for forms x2, moved code in views + tests, new URL
$ <strong>git commit -a</strong></pre>
</div>
</div>
<div class="paragraph">
<p>And we can cross out an item on the to-do list:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Adjust model so that items are associated with different lists</em></p>
</li>
<li>
<p><em>Add unique URLs for each list</em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add a URL for creating a new list via POST</span></em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_biting_the_bullet_adjusting_our_models">Biting the bullet: Adjusting Our Models</h3>
<div class="paragraph">
<p>
Enough housekeeping with our URLs. It&#8217;s time to bite the bullet and
change our models.  Let&#8217;s adjust the model unit test. Just for a change, I&#8217;ll
present the changes in the form of a diff:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line change"><span class="change">@@</span> -1,5 +1,5 <span class="change">@@</span></span>
 from django.test import TestCase
<span class="line delete"><span class="delete">-</span>from lists.models import Item</span>
<span class="line insert"><span class="insert">+</span>from lists.models import Item<span class="eyecatcher">, List</span></span>


 class HomePageTest(TestCase):
<span class="change"><span class="change">@@</span> -44,22 +44,32 <span class="change">@@</span></span> class ListViewTest(TestCase):



<span class="line delete"><span class="delete">-</span>class <span class="eyecatcher">ItemModel</span>Test(TestCase):</span>
<span class="line insert"><span class="insert">+</span>class <span class="eyecatcher">ListAndItemModels</span>Test(TestCase):</span>

     def test_saving_and_retrieving_items(self):
<span class="line insert"><span class="insert">+</span>        list_ = List()</span>
<span class="line insert"><span class="insert">+</span>        list_.save()</span>
<span class="line insert"><span class="insert">+</span></span>
         first_item = Item()
         first_item.text = 'The first (ever) list item'
<span class="line insert"><span class="insert">+</span>        first_item.list = list_</span>
         first_item.save()

         second_item = Item()
         second_item.text = 'Item the second'
<span class="line insert"><span class="insert">+</span>        second_item.list = list_</span>
         second_item.save()

<span class="line insert"><span class="insert">+</span>        saved_list = List.objects.first()</span>
<span class="line insert"><span class="insert">+</span>        self.assertEqual(saved_list, list_)</span>
<span class="line insert"><span class="insert">+</span></span>
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2)

         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, 'The first (ever) list item')
<span class="line insert"><span class="insert">+</span>        self.assertEqual(first_saved_item.list, list_)</span>
         self.assertEqual(second_saved_item.text, 'Item the second')
<span class="line insert"><span class="insert">+</span>        self.assertEqual(second_saved_item.list, list_)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We create a new <code>List</code> object, and then we assign each item to it
by assigning it as its <code>.list</code> property.  We check the list is properly
saved, and we check that the two items have also saved their relationship
to the list.  You&#8217;ll also notice that we can compare list objects with each
other directly (<code>saved_list</code> and <code>list_</code>)&#8212;behind the scenes, these
will compare themselves by checking their primary key (the <code>.id</code> attribute)
is the same.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
I&#8217;m using the variable name <code>list_</code> to avoid "shadowing" the Python
    built-in <code>list</code> function.  It&#8217;s ugly, but all the other options I tried
    were equally ugly or worse (<code>my_list</code>, <code>the_list</code>, <code>list1</code>, <code>listey</code>&#8230;&#8203;).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Time for another unit-test/code cycle.</p>
</div>
<div class="paragraph">
<p>For the first couple of iterations, rather than explicitly showing you what
code to enter in between every test run, I&#8217;m only going to show you the
expected error messages from running the tests.  I&#8217;ll let you figure out what
each minimal code change should be on your own:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Need a hint?  Go back and take a look at the steps we took to introduce
    the <code>Item</code> model in <a href="/book/chapter_post_and_database.html">the last chapter</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your first error should be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ImportError: cannot import name 'List'</pre>
</div>
</div>
<div class="paragraph">
<p>Fix that, then you should see:</p>
</div>
<div class="listingblock dofirst-ch07l028-1">
<div class="content">
<pre>AttributeError: 'List' object has no attribute 'save'</pre>
</div>
</div>
<div class="paragraph">
<p>Next you should see:</p>
</div>
<div class="listingblock dofirst-ch07l028-2">
<div class="content">
<pre>django.db.utils.OperationalError: no such table: lists_list</pre>
</div>
</div>
<div class="paragraph">
<p>So we run a <code>makemigrations</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py makemigrations</strong>
Migrations for 'lists':
  lists/migrations/0003_list.py
    - Create model List</pre>
</div>
</div>
<div class="paragraph">
<p>And then you should see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(first_saved_item.list, list_)
AttributeError: 'Item' object has no attribute 'list'</pre>
</div>
</div>
<div class="sect3">
<h4 id="_a_foreign_key_relationship">A Foreign Key Relationship</h4>
<div class="paragraph">
<p>


How do we give our <code>Item</code> a list attribute?  Let&#8217;s just try naively making it
like the <code>text</code> attribute (and here&#8217;s your chance to see whether your
solution so far looks like mine by the way):</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/models.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.db</span> <span class="keyword">import</span> <span class="include">models</span>

<span class="keyword">class</span> <span class="class">List</span>(models.Model):
    <span class="keyword">pass</span>

<span class="keyword">class</span> <span class="class">Item</span>(models.Model):
    text = models.TextField(default=<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)
    list = models.TextField(default=<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As usual, the tests tell us we need a migration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
django.db.utils.OperationalError: no such column: lists_item.list

$ <strong>python manage.py makemigrations</strong>
Migrations for 'lists':
  lists/migrations/0004_item_list.py
    - Add field list to item</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see what that gives us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: 'List object' != &lt;List: List object&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re not quite there. Look closely at each side of the <code>!=</code>.  Django has only
saved the string representation of the <code>List</code> object. To save the relationship
to the object itself, we tell Django about the relationship between the two
classes using a <code>ForeignKey</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/models.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.db</span> <span class="keyword">import</span> <span class="include">models</span>

<span class="keyword">class</span> <span class="class">List</span>(models.Model):
    <span class="keyword">pass</span>


<span class="keyword">class</span> <span class="class">Item</span>(models.Model):
    text = models.TextField(default=<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)
    list = models.ForeignKey(List, default=<span class="predefined-constant">None</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>
That&#8217;ll need a migration too.  Since the last one was a red herring, let&#8217;s
delete it and replace it with a new one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>rm lists/migrations/0004_item_list.py</strong>
$ <strong>python manage.py makemigrations</strong>
Migrations for 'lists':
  lists/migrations/0004_item_list.py
    - Add field list to item</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Deleting migrations is dangerous.  We do need to do it now and again,
    because we don&#8217;t always get our models code right on the first go. But if
    you delete a migration that&#8217;s already been applied to a database somewhere,
    Django will be confused about what state it&#8217;s in, and how to apply future
    migrations. You should only do it when you&#8217;re sure the migration hasn&#8217;t
    been used.  A good rule of thumb is that you should never delete or modify
    a migration that&#8217;s already been committed to your VCS.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_adjusting_the_rest_of_the_world_to_our_new_models">Adjusting the Rest of the World to Our New Models</h4>
<div class="paragraph">
<p>Back in our tests, now what happens?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
ERROR: test_displays_all_items (lists.tests.ListViewTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_can_save_a_POST_request (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id

Ran 6 tests in 0.021s

FAILED (errors=3)</pre>
</div>
</div>
<div class="paragraph">
<p>Oh dear!</p>
</div>
<div class="paragraph">
<p>There is some good news. Although it&#8217;s hard to see, our model tests are
passing.  But three of our view tests are failing nastily.</p>
</div>
<div class="paragraph">
<p>The reason is because of the new relationship we&#8217;ve introduced between
Items and Lists, which requires each item to have a parent list, which
our old tests and code aren&#8217;t prepared for.</p>
</div>
<div class="paragraph">
<p>Still, this is exactly why we have tests! Let&#8217;s get them working again.  The
easiest is the <code>ListViewTest</code>; we just create a parent list for our two test
items:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py (ch07l031)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_displays_all_items</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 1</span><span class="delimiter">'</span></span>, list=list_)
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 2</span><span class="delimiter">'</span></span>, list=list_)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gets us down to two failing tests, both on tests that try to POST to our
<code>new_list</code> view. Decoding the tracebacks using our usual technique, working
back from error, to line of test code, to, buried in there somewhere, the line
of our own code that caused the failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>File "/.../superlists/lists/views.py", line 9, in new_list
Item.objects.create(text=request.POST['item_text'])</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s when we try and create an item without a parent list. So we make a similar
change in the view:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">lists.models</span> <span class="keyword">import</span> <span class="include">Item</span>, <span class="include">List</span>
[...]
<span class="keyword">def</span> <span class="function">new_list</span>(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that gets our tests passing again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 6 tests in 0.030s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Are you cringing internally at this point?  <em>Arg! This feels so wrong, we
create a new list for every single new item submission, and we&#8217;re still just
displaying all items as if they belong to the same list!</em>
I know, I feel the same.  The step-by-step approach, in which you go
from working code to working code, is counterintuitive. I always feel like
just diving in and trying to fix everything all in one go, instead of going
from one weird half-finished state to another.  But remember the Testing Goat!
When you&#8217;re up a mountain, you want to think very carefully about where you put
each foot, and take one step at a time, checking at each stage that the place
you&#8217;ve put it hasn&#8217;t caused you to fall off a cliff.</p>
</div>
<div class="paragraph">
<p>So just to reassure ourselves that things have worked, we rerun the FT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
[...]</pre>
</div>
</div>
<div class="paragraph">
<p>Sure enough, it gets all the way through to where we were before.  We haven&#8217;t broken
anything, and we&#8217;ve made a change to the database.  That&#8217;s something to be
pleased with! Let&#8217;s commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git status</strong> # 3 changed files, plus 2 migrations
$ <strong>git add lists</strong>
$ <strong>git diff --staged</strong>
$ <strong>git commit</strong></pre>
</div>
</div>
<div class="paragraph">
<p>And we can cross out another item on the to-do list:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em><span class="strikethrough line-through">Adjust model so that items are associated with different lists</span></em></p>
</li>
<li>
<p><em>Add unique URLs for each list</em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add a URL for creating a new list via POST</span></em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_each_list_should_have_its_own_url">Each List Should Have Its Own URL</h3>
<div class="paragraph">
<p>


What shall we use as the unique identifier for our lists?  Probably the
simplest thing, for now, is just to use the auto-generated <code>id</code> field from the
database. Let&#8217;s change <code>ListViewTest</code> so that the two tests point at new
URLs.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll also change the old <code>test_displays_all_items</code> test and call it
<code>test_displays_only_items_for_that_list</code> instead, and make it check that
only the items for a specific list are displayed:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py (ch07l033)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_uses_list_template</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        response = <span class="predefined-constant">self</span>.client.get(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{list_.id}/</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertTemplateUsed(response, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>)


    <span class="keyword">def</span> <span class="function">test_displays_only_items_for_that_list</span>(<span class="predefined-constant">self</span>):
        correct_list = List.objects.create()
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 1</span><span class="delimiter">'</span></span>, list=correct_list)
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">itemey 2</span><span class="delimiter">'</span></span>, list=correct_list)
        other_list = List.objects.create()
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">other list item 1</span><span class="delimiter">'</span></span>, list=other_list)
        Item.objects.create(text=<span class="string"><span class="delimiter">'</span><span class="content">other list item 2</span><span class="delimiter">'</span></span>, list=other_list)

        response = <span class="predefined-constant">self</span>.client.get(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{correct_list.id}/</span><span class="delimiter">'</span></span>)

        <span class="predefined-constant">self</span>.assertContains(response, <span class="string"><span class="delimiter">'</span><span class="content">itemey 1</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertContains(response, <span class="string"><span class="delimiter">'</span><span class="content">itemey 2</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertNotContains(response, <span class="string"><span class="delimiter">'</span><span class="content">other list item 1</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertNotContains(response, <span class="string"><span class="delimiter">'</span><span class="content">other list item 2</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A couple more of those lovely f-strings in this listing!  If they&#8217;re
    still a bit of a mystery, take a look at the
<a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">docs</a>,
    (although if your formal CS education is as bad as mine, you&#8217;ll probably
    skip the formal grammar).
    
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Running the unit tests gives an expected 404, and another related error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404
(expected 200)
[...]
FAIL: test_uses_list_template (lists.tests.ListViewTest)
AssertionError: No templates used to render the response</pre>
</div>
</div>
<div class="sect3">
<h4 id="_capturing_parameters_from_urls">Capturing Parameters from URLs</h4>
<div class="paragraph">
<p>
It&#8217;s time to learn how we can pass parameters from URLs to views:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^$</span><span class="delimiter">'</span></span>, views.home_page, name=<span class="string"><span class="delimiter">'</span><span class="content">home</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/(.+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We adjust the regular expression for our URL to include a <em>capture group</em>,
<code>(.+)</code>, which will match any characters, up to the following <code>/</code>. The captured
text will get passed to the view as an argument.</p>
</div>
<div class="paragraph">
<p>In other words, if we go to the URL <em>/lists/1/</em>, <code>view_list</code> will get a second
argument after the normal <code>request</code> argument, namely the string <code>"1"</code>.
If we go to <em>/lists/foo/</em>, we get <code>view_list(request, "foo")</code>.</p>
</div>
<div class="paragraph">
<p>But our view doesn&#8217;t expect an argument yet! Sure enough, this causes problems:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
[...]
ERROR: test_uses_list_template (lists.tests.ListViewTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
[...]
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
FAILED (errors=3)</pre>
</div>
</div>
<div class="paragraph">
<p>We can fix that easily with a dummy parameter in <em>views.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re down to our expected failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
AssertionError: 1 != 0 : Response should not contain 'other list item 1'</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s make our view discriminate over which items it sends to the
template:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    items = Item.objects.filter(list=list_)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">items</span><span class="delimiter">'</span></span>: items})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adjusting_new_list_to_the_new_world">Adjusting new_list to the New World</h4>
<div class="paragraph">
<p>Oops, now we get errors in another test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: test_redirects_after_POST (lists.tests.NewListTest)
ValueError: invalid literal for int() with base 10:
'the-only-list-in-the-world'</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at this test then, since it&#8217;s moaning:</p>
</div>
<div class="listingblock sourcecode currentcontents">
<div class="title">lists/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_redirects_after_POST</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertRedirects(response, <span class="string"><span class="delimiter">'</span><span class="content">/lists/the-only-list-in-the-world/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It looks like it hasn&#8217;t been adjusted to the new world of Lists and Items.
The test should be saying that this view redirects to the URL of the specific
new list it just created:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py (ch07l036-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_redirects_after_POST</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new list item</span><span class="delimiter">'</span></span>})
        new_list = List.objects.first()
        <span class="predefined-constant">self</span>.assertRedirects(response, f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{new_list.id}/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That still gives us the <em>invalid literal</em> error. We take a look at the view
itself, and change it so it redirects to a valid place:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch07l036-2)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">return</span> redirect(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{list_.id}/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gets us back to passing unit tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python3 manage.py test lists</strong>
[...]
......
 ---------------------------------------------------------------------
Ran 6 tests in 0.033s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>What about the functional tests?  We must be almost there?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_functional_tests_detect_another_regression">The functional tests detect another regression</h3>
<div class="paragraph">
<p>Well, almost:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>F.
======================================================================
FAIL: test_can_start_a_list_for_one_user
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/tests.py", line 67, in
test_can_start_a_list_for_one_user
    self.wait_for_row_in_list_table('2: Use peacock feathers to make a fly')
[...]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Use
peacock feathers to make a fly']

 ---------------------------------------------------------------------
Ran 2 tests in 8.617s

FAILED (failures=1)</pre>
</div>
</div>
<div class="paragraph">
<p>Our new test is actually passing, and different users can get different lists,
but the old test is warning us of a regression.  It looks like you can&#8217;t
add a second item to a list any more.  It&#8217;s because of our quick-and dirty hack
where create a new list for every single POST submission. This is exactly what
we have functional tests for!</p>
</div>
<div class="paragraph">
<p>And it correlates nicely with the last item on our to-do list:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em><span class="strikethrough line-through">Adjust model so that items are associated with different lists</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add unique URLs for each list</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add a URL for creating a new list via POST</span></em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_one_more_view_to_handle_adding_items_to_an_existing_list">One More View to Handle Adding Items to an Existing List</h3>
<div class="paragraph">
<p>

We need a URL and view to handle adding a new item to an existing list
(<em>/lists/&lt;list_id&gt;/add_item</em>).  We&#8217;re getting pretty good at these now, so
let&#8217;s knock one together quickly:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewItemTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request_to_an_existing_list</span>(<span class="predefined-constant">self</span>):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        <span class="predefined-constant">self</span>.client.post(
            f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{correct_list.id}/add_item</span><span class="delimiter">'</span></span>,
            data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>}
        )

        <span class="predefined-constant">self</span>.assertEqual(Item.objects.count(), <span class="integer">1</span>)
        new_item = Item.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertEqual(new_item.list, correct_list)


    <span class="keyword">def</span> <span class="function">test_redirects_to_list_view</span>(<span class="predefined-constant">self</span>):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        response = <span class="predefined-constant">self</span>.client.post(
            f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{correct_list.id}/add_item</span><span class="delimiter">'</span></span>,
            data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>}
        )

        <span class="predefined-constant">self</span>.assertRedirects(response, f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{correct_list.id}/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Are you wondering about <code>other_list</code>?  A bit like in the tests for
    viewing a specific list, it&#8217;s important that we add items to a specific
    list.  Adding this second object to the database prevents me from using
    a hack like List.objects.first() in the implementation.  That would be
    a stupid thing to do, and you can go too far down the road of testing
    for all the stupid things you must not do (there are an infinite number
    of those after all). It&#8217;s a judgement call, but this one feels worth it.
    There&#8217;s some more discussion of this in <a href="/book/chapter_advanced_forms.html#testing-for-stupidity">[testing-for-stupidity]</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: 0 != 1
[...]
AssertionError: 301 != 302 : Response didn't redirect as expected: Response
code was 301 (expected 302)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_beware_of_greedy_regular_expressions">Beware of Greedy Regular Expressions!</h4>
<div class="paragraph">
<p>
That&#8217;s a little strange. We haven&#8217;t actually specified a URL for
<em>/lists/1/add_item</em> yet, so our expected failure is <code>404 != 302</code>.  Why are we
getting a 301?</p>
</div>
<div class="paragraph">
<p>This was a bit of a puzzler! It&#8217;s because we&#8217;ve used a very "greedy"
regular expression in our URL:</p>
</div>
<div class="listingblock sourcecode currentcontents">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/(.+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),</code></pre>
</div>
</div>
<div class="paragraph">
<p>Django has some built-in code to issue a permanent redirect (301) whenever
someone asks for a URL which is <em>almost</em> right, except for a missing slash.
In this case, <em>/lists/1/add_item/</em> would be a match for <code>lists/(.+)/</code>, with
the <code>(.+)</code> capturing <code>1/add_item</code>.  So Django "helpfully" guesses that we
actually wanted the URL with a trailing slash.</p>
</div>
<div class="paragraph">
<p>We can fix that by making our URL pattern explicitly capture only numerical
digits, by using the regular expression <code>\d</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gives us the failure we expected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: 0 != 1
[...]
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_last_new_url">The Last New URL</h4>
<div class="paragraph">
<p>

Now we&#8217;ve got our expected 404, let&#8217;s add a new URL for adding new items to
existing lists:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^$</span><span class="delimiter">'</span></span>, views.home_page, name=<span class="string"><span class="delimiter">'</span><span class="content">home</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/(</span><span class="content">\d</span><span class="content">+)/add_item$</span><span class="delimiter">'</span></span>, views.add_item, name=<span class="string"><span class="delimiter">'</span><span class="content">add_item</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Three very similar-looking URLs there.  Let&#8217;s make a note on our
to-do list; they look like good candidates for a refactoring.</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em><span class="strikethrough line-through">Adjust model so that items are associated with different lists</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add unique URLs for each list</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add a URL for creating a new list via POST</span></em></p>
</li>
<li>
<p><em>Add URLs for adding a new item to an existing list via POST</em></p>
</li>
<li>
<p><em>Refactor away some duplication in urls.py</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Back to the tests, we get the usual missing module view objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AttributeError: module 'lists.views' has no attribute 'add_item'</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_last_new_view">The Last New View</h4>
<div class="paragraph">
<p>Let&#8217;s try:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">add_item</span>(request):
    <span class="keyword">pass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Aha:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>TypeError: add_item() takes 1 positional argument but 2 were given</pre>
</div>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">add_item</span>(request, list_id):
    <span class="keyword">pass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ValueError: The view lists.views.add_item didn't return an HttpResponse object.
It returned None instead.</pre>
</div>
</div>
<div class="paragraph">
<p>We can copy the <code>redirect</code> from <code>new_list</code> and the <code>List.objects.get</code> from
<code>view_list</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">add_item</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    <span class="keyword">return</span> redirect(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{list_.id}/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That takes us to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1</pre>
</div>
</div>
<div class="paragraph">
<p>Finally we make it save our new list item:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">add_item</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">return</span> redirect(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{list_.id}/</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we&#8217;re back to passing tests.

</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 8 tests in 0.050s

OK</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_testing_the_response_context_objects_directly">Testing the response context objects directly</h4>
<div class="paragraph">
<p>

We&#8217;ve got our new view and URL for adding items to existing lists, now we just
need to actually use it in our <em>list.html</em> template. So we open it up to adjust
the form tag&#8230;&#8203;</p>
</div>
<div class="listingblock sourcecode skipme">
<div class="title">lists/templates/list.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">    <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">but what should we put here?</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>... oh. To get the URL for adding to the current list, the template needs to
know what list it&#8217;s rendering, as well as what the items are.  We want to
be able to do something like this:</p>
</div>
<div class="listingblock sourcecode skipme">
<div class="title">lists/templates/list.html</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">    <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">/lists/{{ list.id }}/add_item</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For that to work, the view will have to pass the list to the template.
Let&#8217;s create a new unit test in <code>ListViewTest</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests.py (ch07l041)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_passes_correct_list_to_template</span>(<span class="predefined-constant">self</span>):
        other_list = List.objects.create()
        correct_list = List.objects.create()
        response = <span class="predefined-constant">self</span>.client.get(f<span class="string"><span class="delimiter">'</span><span class="content">/lists/{correct_list.id}/</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertEqual(response.context[<span class="string"><span class="delimiter">'</span><span class="content">list</span><span class="delimiter">'</span></span>], correct_list)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>response.context</code> represents the context we&#8217;re going to pass into
the render function&#8212;&#8203;the Django test client puts it on the <code>response</code>
object for us, to help with testing.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That gives us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>KeyError: 'list'</pre>
</div>
</div>
<div class="paragraph">
<p>because we&#8217;re not passing <code>list</code> into the template.  It actually gives us an
opportunity to simplify a little:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">list</span><span class="delimiter">'</span></span>: list_})</code></pre>
</div>
</div>
<div class="paragraph">
<p>That, of course, will break one of our old tests, because the template
needed <code>items</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
AssertionError: False is not true : Couldn't find 'itemey 1' in response</pre>
</div>
</div>
<div class="paragraph">
<p>But we can fix it in <em>list.html</em>, as well as adjusting the form&#8217;s POST action:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/list.html (ch07l043)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">    <span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">/lists/{{ list.id }}/add_item</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>  <i class="conum" data-value="1"></i><b>(1)</b>

      [...]

      {% for item in list.item_set.all %}  <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="tag">&lt;tr&gt;</span><span class="tag">&lt;td&gt;</span>{{ forloop.counter }}: {{ item.text }}<span class="tag">&lt;/td&gt;</span><span class="tag">&lt;/tr&gt;</span>
      {% endfor %}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There&#8217;s our new form action.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>.item_set</code> is called a
<a href="https://docs.djangoproject.com/en/1.11/topics/db/queries/#following-relationships-backward">reverse lookup</a>.
It&#8217;s one of Django&#8217;s incredibly useful bits of ORM that lets you look up an
object&#8217;s related items from a different table&#8230;&#8203;</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So that gets the unit tests to pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 9 tests in 0.040s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>How about the FTs?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
..
 ---------------------------------------------------------------------
Ran 2 tests in 9.771s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>HOORAY!  Oh, and a quick check on our to-do list:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em><span class="strikethrough line-through">Adjust model so that items are associated with different lists</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add unique URLs for each list</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add a URL for creating a new list via POST</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Add URLs for adding a new item to an existing list via POST</span></em></p>
</li>
<li>
<p><em>Refactor away some duplication in urls.py</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>
Irritatingly, the Testing Goat is a stickler for tying up loose ends too, so
we&#8217;ve got to do this one final thing.</p>
</div>
<div class="paragraph">
<p>

Before we start, we&#8217;ll do a commit&#8212;&#8203;always make sure you&#8217;ve got a commit
of a working state before embarking on a refactor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git diff</strong>
$ <strong>git commit -am "new URL + view for adding to existing lists. FT passes :-)"</strong></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_final_refactor_using_url_includes">A Final Refactor Using URL includes</h3>
<div class="paragraph">
<p>
<em>superlists/urls.py</em> is really meant for URLs that apply to your
entire site.  For URLs that only apply to the <code>lists</code> app, Django encourages us
to use a separate <em>lists/urls.py</em>, to make the app more self-contained.  The
simplest way to make one is to use a copy of the existing <em>urls.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>cp superlists/urls.py lists/</strong></pre>
</div>
</div>
<div class="paragraph">
<p>Then we replace three lines in <em>superlists/urls.py</em> with an <code>include</code>.</p>
</div>
<div class="listingblock sourcecode">
<div class="title">superlists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.conf.urls</span> <span class="keyword">import</span> <span class="include">include</span>, <span class="include">url</span>
<span class="keyword">from</span> <span class="include">lists</span> <span class="keyword">import</span> <span class="include">views</span> <span class="keyword">as</span> list_views  <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">from</span> <span class="include">lists</span> <span class="keyword">import</span> <span class="include">urls</span> <span class="keyword">as</span> list_urls  <i class="conum" data-value="1"></i><b>(1)</b>

urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^$</span><span class="delimiter">'</span></span>, list_views.home_page, name=<span class="string"><span class="delimiter">'</span><span class="content">home</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^lists/</span><span class="delimiter">'</span></span>, include(list_urls)),  <i class="conum" data-value="2"></i><b>(2)</b>
]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>While we&#8217;re at it, we use the <code>import x as y</code> syntax to alias <code>views</code> and
<code>urls</code>.  This is good practice in your top-level <em>urls.py</em>, because it will
let us import views and urls from multiple apps if we want&#8212;&#8203;and indeed we
will need to later on in the book.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here&#8217;s the <code>include</code>. Notice that it can take a part of a URL regex as a
prefix, which will be applied to all the included URLs (this is the bit
where we reduce duplication, as well as giving our code a better
structure):</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Back in <em>lists/urls.py</em> we can trim down to only include the latter part
of our three URLs, and none of the other stuff from the parent <em>urls.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/urls.py (ch07l046)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.conf.urls</span> <span class="keyword">import</span> <span class="include">url</span>
<span class="keyword">from</span> <span class="include">lists</span> <span class="keyword">import</span> <span class="include">views</span>

urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^(</span><span class="content">\d</span><span class="content">+)/add_item$</span><span class="delimiter">'</span></span>, views.add_item, name=<span class="string"><span class="delimiter">'</span><span class="content">add_item</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rerun the unit tests to check everything worked.</p>
</div>
<div class="paragraph">
<p>When I did it, I couldn&#8217;t quite believe I did it correctly on the first go. It
always pays to be skeptical of your own abilities, so I deliberately changed
one of the URLs slightly, just to check if it broke a test. It did. We&#8217;re
covered.</p>
</div>
<div class="paragraph">
<p>Feel free to try it yourself!  Remember to change it back, check the tests
all pass again, and then a final commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git status</strong>
$ <strong>git add lists/urls.py</strong>
$ <strong>git add superlists/urls.py</strong>
$ <strong>git diff --staged</strong>
$ <strong>git commit</strong></pre>
</div>
</div>
<div class="paragraph">
<p>Phew. A marathon chapter. But we covered a number of important topics, starting
with test isolation, and then some thinking about design. We covered some rules
of thumb like "YAGNI" and "three strikes then refactor". But, most importantly,
we saw how to adapt an existing site step by step, going from working state to
working state, in order to iterate towards a new design.</p>
</div>
<div class="paragraph">
<p>I&#8217;d say we&#8217;re pretty close to being able to ship this site, as the very first
beta of the superlists website that&#8217;s going to take over the world.  Maybe it
needs a little prettification first&#8230;&#8203;let&#8217;s look at what we need to do to
deploy it in the next couple of chapters.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Some more TDD Philosophy</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Working State to Working State (aka The Testing Goat vs. Refactoring Cat)</dt>
<dd>
<p>Our natural urge is often to dive in and fix everything at once&#8230;&#8203;but if
we&#8217;re not careful, we&#8217;ll end up like Refactoring Cat, in a situation with
loads of changes to our code and nothing working.  The Testing Goat
encourages us to take one step at a time, and go from working state to
working state.


</p>
</dd>
<dt class="hdlist1">Split work out into small, achievable tasks</dt>
<dd>
<p>Sometimes this means starting with "boring" work rather than diving
straight in with the fun stuff, but you&#8217;ll have to trust that YOLO-you
in the parallel universe is probably having a bad time, having broken
everything, and struggling to get their app working again.</p>
</dd>
<dt class="hdlist1">YAGNI</dt>
<dd>
<p>You ain&#8217;t gonna need it!  Avoid the temptation to write code that you
think <em>might</em> be useful, just because it suggests itself at the time.
Chances are, you won&#8217;t use it, or you won&#8217;t have anticipated your
future requirements correctly.  See <a href="/book/chapter_outside_in.html">[chapter_outside_in]</a> for one
methodology that helps us avoid this trap.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-04-01 11:49:25 BST
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = 'chapter_working_incrementally';
    };
    
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//obeythetestinggoat.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>