<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Fast Tests, Slow Tests, and Hot Lava</title>
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
      var subheaders = document.getElementsByClassName('sectlevel2');
      var section;
      for (var i=0; i<subheaders.length; i++) {
        section = subheaders[i];
        if (section.innerHTML.indexOf(window.location.pathname) === -1) {
          section.style.display = 'none';
        } else {
          section.scrollIntoView && section.scrollIntoView();
        }
      }

    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_27_hot_lava">Fast Tests, Slow Tests, and Hot Lava</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The database is Hot Lava!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; <a href="https://www.youtube.com/watch?v=bsmFVb8guMU">Casey Kinsey</a>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve come to the end of the book,
and the end of our journey with this To-Do app and its tests.
Let&#8217;s recap our test structure so far:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We have a suite of "functional tests" that use Selenium to test that the whole app really works.
On several occations, the FTs have saved us from shipping broken code,
whether it was broken CSS, a broken database due to filesystem permissions, or broken email integration.</p>
</li>
<li>
<p>And we have a suit of "unit tests" that use Django&#8217;s test client,
that enable us to test-drive our code for models, forms, views, urls, and even, to some extent, templates.
They&#8217;ve enabled us to build the app incrementally, to refactor with confidence,
and they&#8217;ve supported a fast unit-test/code cycle.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ve also spent a good bit of time on our infrastructure,
packaging up our app with Docker for ease of deployment,
and we&#8217;ve set up a CI pipeline to run our tests automatically on push.</p>
</div>
<div class="paragraph">
<p>Being a simple app that could fit in a book though,
there are inevitably some limitations and simplifications in our approach.
In this chapter I&#8217;d like to talk about how to carry your testing principles forward,
as you move into larger, more complex applications in the real world.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s find out why someone might say that the database is hot lava!</p>
</div>
<div class="sect2">
<h3 id="_why_do_we_test_our_desiderata_for_effective_tests">Why Do We Test? Our Desiderata for Effective Tests</h3>
<div class="paragraph">
<p>At <a href="https://testdesiderata.com/">testdesiderata.com</a>, Kent Beck and Kelly Sutton
outline several desiderata (desirable characteristics) for tests:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Test Desiderata</caption>
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Isolated</strong>: tests should return the same results regardless of the order in which they are run.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Composable</strong>: I should be able to test different dimensions of variability separately and combine the results.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Deterministic</strong>: if nothing changes, the test result shouldn&#8217;t change.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Fast</strong>: tests should run quickly.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Writable</strong>: tests should be cheap to write relative to the cost of the code being tested.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Readable</strong>: tests should be comprehensible for reader, invoking the motivation for writing this particular test.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Behavioural</strong>: tests should be sensitive to changes in the behaviour of the code under test. If the behaviour changes, the test result should change.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Structure-agnostic</strong>: tests should not change their result if the structure of the code changes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Automated</strong>: tests should run without human intervention.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Specific</strong>: if a test fails, the cause of the failure should be obvious.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Predictive</strong>: if the tests all pass, then the code under test should be suitable for production.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Inspiring</strong>: passing the tests should inspire confidence</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We&#8217;ve talked about almost all of these desiderata in the book:
we talked about <em>isolation</em> when we switched to using the Django test runner.
We talked about <em>composability</em> when discussing the car factory example in <a href="/book/chapter_21_mocking_2.html">[chapter_21_mocking_2]</a>.
We talked about tests being <em>readable</em> when we talked about the Given/When/Then structure,
and when implementing helper methods in our FTs.
We talked about testing <em>behaviour</em> rather than implementation at several points,
including in the mocking chapters.
We talked about <em>structure</em> in the forms chapters,
when we showed that the higher-level views tests enabled us to refactor more freely than the lower-level forms tests.
We&#8217;ve talked about splitting up our tests to have fewer assertions to make them more <em>specific</em>.
We talked about <em>determinism</em> when discussing flaky tests and the use of <code>wait_for()</code> in our FTs, for example, as well as in the production debugging chapter.</p>
</div>
<div class="paragraph">
<p>In this chapter, we&#8217;re going to talk primarily about speed, and about what makes tests inspiring.</p>
</div>
<div class="paragraph">
<p>But it&#8217;s worth taking a step back from the list above, and saying:
"what do we want from our tests?"</p>
</div>
<div class="sect3">
<h4 id="_confidence_correctness_preventing_regression">Confidence &amp; Correctness (Preventing Regression)</h4>
<div class="paragraph">
<p>A fundamental part of programming is that now and again
you need to check whether "it works".
Automated testing is the solution to the fact that checking things manually
quickly gets tedious, and unreliable.
We want our tests to tell us that our code works,
both at the low level of individual functions or classes,
and at the higher level of "does it all hang together?".</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_productive_workflow">A Productive Workflow</h4>
<div class="paragraph">
<p>Our tests need to be fast enough to write,
but more importantly, fast to run.
We want to get into a smooth, productive workflow,
and that holy credo of programmers, the "flow state".
Beyond that, we want our tests to take some of the stress out of programming,
encouraging us to work in small increments,
with frequent bursts of dopamine from seeing green tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="_driving_better_design">Driving Better Design</h4>
<div class="paragraph">
<p>And our tests should help us to write <em>better</em> code.
Firstly, by enabling fearless refactoring.
Secondly, by giving us feedback on the design of our code.
Writing the tests first lets us think about our API from the outside-in,
before we write it&#8212;&#8203;and we&#8217;ve seen that.
But in this chapter we&#8217;ll also talk about the potential for
tests to give you feedback on our design in more subtle ways.
As we&#8217;ll see, designing code to be more testable
often leads to code that has clearly identified dependencies,
and is more modular and more decoupled.</p>
</div>
<div class="paragraph">
<p>As we continuously think about what kinds of tests to write,
we are trying to achieve the optimum balance of these different desiderata.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_were_our_unit_tests_integration_tests_all_along_what_is_that_warm_glow_coming_from_the_database">Were Our Unit Tests Integration Tests All Along? What is That Warm Glow Coming from the Database?</h3>
<div class="paragraph">
<p>

Almost all of the "unit" tests in the book
should perhaps have been called <em>integration</em> tests,
because they all rely on Django&#8217;s test runner,
which gives us a real database to talk to.
Many also use the Django Test Client,
which does a lot of magic with the middleware layers that sit between requests.
The end result is that our tests are heavily integrated with both the database,
and Django itself.</p>
</div>
<div class="sect3">
<h4 id="_weve_been_in_the_sweet_spot">We&#8217;ve Been in the "Sweet Spot"</h4>
<div class="paragraph">
<p>Now, actually, this has been a pretty good thing for us so far.
We&#8217;re very much in the "sweet spot" of Django&#8217;s testing tools,
and our unit tests have been fast enough to enable a smooth workflow,
and they&#8217;ve given us a lot that our application really works,
from the models all the way up to the templates.
By allying them with a small-ish suite of functional tests,
we&#8217;ve got a lot of confidence in our code.
And we&#8217;ve been able to use them to get at least a bit of feedback on our design,
and to enable lots of refactoring.</p>
</div>
</div>
<div class="sect3">
<h4 id="_what_is_a_true_unit_test_does_it_matter">What is a "True" Unit Test?  Does it Matter?</h4>
<div class="paragraph">
<p>But people will often tell you that a "true" unit test should be more isolated.
It&#8217;s meant to test a single "unit" of software,
and your database "should" be outside of that.
Why do they say that?
Apart from the smug from should-ing us?</p>
</div>
<div class="paragraph">
<p>As you can tell,
I think the argument from <em>definitions</em> is a bit of a red herring.
But you might hear instead, "the database is hot lava!"
as Casey Kinsey put it in a memorable DjangoCon talk.
There is real feeling and real experience behind these comments.
What are people getting at?</p>
</div>
</div>
<div class="sect3">
<h4 id="_integration_and_functional_tests_get_slower_over_time">Integration and Functional Tests Get Slower Over Time</h4>
<div class="paragraph">
<p>The problem is that, as your application and your codebase grows,
involving the database in every single test starts to carry an unacceptable cost,
in terms of the speed of execution of nothing else;
Casey&#8217;s company was struggling with test suites that took several hours.</p>
</div>
<div class="paragraph">
<p>At PythonAnywhere, our functional test suite didn&#8217;t just rely on the database,
it would spin up a full test cluster of 6 virtual machines.
A full run used to take at least 12 hours,
and we&#8217;d have to wait overnight for our results.
That was one of the least productive parts of an otherwise extraordinary workflow.</p>
</div>
<div class="paragraph">
<p>At Kraken, the full test suite does only take about 45 minutes,
which is not bad for nearly 10 million lines of code,
but that&#8217;s only thanks to a quite frankly ridiculous level of parallelisation
and associated expenditure on CI.
We&#8217;re now spending a lot of effort on trying to move more of our unit
tests to being "true" unit tests.</p>
</div>
<div class="paragraph">
<p>The problem is that these things don&#8217;t scale linearly.
The more database tables you have,
the more relationships between them,
and that starts to increase geometrically.</p>
</div>
<div class="paragraph">
<p>So you can see why, over time, these kinds of tests
are going to fail to meet our desiderata because they&#8217;re too slow
to enable a productive workflow and a fast enough feedback cycle.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Don&#8217;t take it from me!
  Gary Bernhardt, a legend in both the Ruby and Python testing world,
  has a talk simply called
  <a href="https://www.youtube.com/watch?v=RAxiiRPHS9k">Fast Test, Slow Test</a>,
  which is a great tour of the problems I&#8217;m discussing here.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The Holy Flow State</div>
<div class="paragraph">
<p>Thinking sociology for a moment, we programmers have our own culture,
and our own tribal religion in a way.
It has many congregations within it
such as the cult of TDD to which you are now initiated.
There are the followers of vim and the heretics of emacs.
But one thing we all agree on, one particular spiritual practice,
our own transcendental meditation, is the holy flow state.
That feeling of pure focus, of concentration,
where hours pass like no time at all,
where code flows naturally from our fingers,
where problems are just tricky enough to be interesting
but not so hard that they defeat us&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>There is absolutely no hope of achieving flow
if you spend your time waiting for a slow test suite to run.
Anything longer than a few seconds and you&#8217;re going to let your attention wander,
you context-switch, and the flow state is gone.
And the flow state is a fragile dream.
Once it&#8217;s gone, it takes a long time to come back.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_were_not_getting_the_full_potential_benefits_of_testing">We&#8217;re not Getting the Full Potential Benefits of Testing</h4>
<div class="paragraph">
<p>TDD gurus often say "it should be called test-driven <em>design</em>,
not test-driven development".  What do they mean by that?</p>
</div>
<div class="paragraph">
<p>We have definitely seen a bit of the positive influence of TDD on our design.
We&#8217;ve talked about how our tests are the first clients of any API we create,
and we&#8217;ve talked about the benefits of "programming by wishful thinking"
and outside-in.</p>
</div>
<div class="paragraph">
<p>But there&#8217;s more to it.
These same TDD gurus also often say that you should "listen to your tests".
Unless you&#8217;ve read
<a href="https://www.obeythetestinggoat.com/book/appendix_purist_unit_tests.html">Online Appendix: Test Isolation and "Listening to Your Tests"</a>,
that will still sound like a bit of a mystery.</p>
</div>
<div class="paragraph">
<p>So, how can we get to a position where our tests are giving us maximum feedback
on our design?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_ideal_of_the_test_pyramid">The Ideal of the Test Pyramid</h3>
<div class="paragraph">
<p>I know I said I didn&#8217;t want to get bogged down into arguments based on definitions,
but let&#8217;s set out the way people normally think about these three types of tests:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Functional/End-to-end tests</dt>
<dd>
<p>FTs check that the system works end-to-end,
exercising the full stack of the application,
including all dependencies and connected external systems.
They are the ultimate test that it all hangs together,
and that things are "really" going to work.</p>
</dd>
<dt class="hdlist1">Integration tests</dt>
<dd>
<p>The purpose of an integration tests should be to checks that the code
you write is integrated correctly with some "external" system or dependency.</p>
</dd>
<dt class="hdlist1">(True) Unit tests</dt>
<dd>
<p>Unit tests are the lowest-level tests,
and are supposed to test a single "unit" of code or behaviour.
The ideal unit test is fully isolated
from everything external to the unit under test
such that changes to things outside cannot break the test.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The canonical advice is that you should aim to have the majority of your tests
be unit tests, with a smaller number of integration tests,
and an even smaller number of functional tests,
as in the classic "Test Pyramid" of <a href="#test_pyramid">The Test Pyramid</a>.</p>
</div>
<div id="test_pyramid" class="imageblock">
<div class="content">
<img src="images/tdd3_2701.png" alt="A Pyramid shape, with a large bottom layer of unit tests, a medium layer of integration tests, and a small peak of FTs">
</div>
<div class="title">Figure 1. The Test Pyramid</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Bottom Layer: Unit Tests (the vast majority)</dt>
<dd>
<p>These isolated tests are fast and pinpoint failures precisely.
We want these to cover the majority of our functionality,
and the entirety of our business logic if possible</p>
</dd>
<dt class="hdlist1">Middle Layer: Integration Tests (a significant portion)</dt>
<dd>
<p>In an ideal world, these are reserved purely for testing the interactions
between our code and external systems, like the database,
or even (arguably) Django itself.
These are slower, but they give us the confidence that our components
work together.</p>
</dd>
<dt class="hdlist1">Top Layer: A minimal set of Functional/End-to-End Tests</dt>
<dd>
<p>These tests are there to give us the ultimate reassurance
that everything works end-to-end and top to bottom.
But because they are the slowest and most brittle,
we want as few of them as possible.</p>
</dd>
</dl>
</div>
<div id="acceptance-tests-sidebar" class="sidebarblock">
<div class="content">
<div class="title">On Acceptance Tests</div>
<div class="paragraph">
<p>What about "acceptance" tests?  You might have heard this term bandied about.
Often people use it to mean the same thing as functional tests or end-to-end tests.</p>
</div>
<div class="paragraph">
<p>But as taught to me by one of the legends of QA at MADE (hi Marta!),
<em>any</em> kind of test can be an acceptance test,
if it maps onto one of your acceptance criteria.</p>
</div>
<div class="paragraph">
<p>The point of an acceptance test is to validate a piece of behaviour
that&#8217;s important to the user.
In our application, that&#8217;s how we&#8217;ve been thinking about our FTs.</p>
</div>
<div class="paragraph">
<p>But, ultimately, using FTs to test every single piece of user-relevant functionality
is not sustainable.
We need to figure out ways to have our integration tests
and unit tests do the work of verifying user-visible behaviour,
understood at the right level of abstraction.</p>
</div>
<div class="paragraph">
<p>Learn more in
<a href="https://youtu.be/knB4jBafR_M">This video on Acceptance Test-Driven Development (ATDD)</a>
by Dave Farley.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avoiding_mock_hell">Avoiding Mock Hell</h3>
<div class="paragraph">
<p>Well that&#8217;s all very well Harry, you might say,
but our current test setup is nothing like this!
How do we get there from <em>here</em>?
We&#8217;ve seen how to use mocks to isolate ourselves from external dependencies.
Are they the solution then?</p>
</div>
<div class="paragraph">
<p>As I was at pains to point out the mocking chapters,
the use of mocks comes with painful trade-offs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They make tests harder to read and write.</p>
</li>
<li>
<p>They leave your tests tightly coupled to implementation details.</p>
</li>
<li>
<p>As a result, they tend to impede refactoring.</p>
</li>
<li>
<p>And in the extreme, you can sometimes end up with mocks testing mocks,
almost entirely disconnected from what the code actually does.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ed Jung calls this <a href="https://youtu.be/CdKaZ7boiZ4">Mock Hell</a>.</p>
</div>
<div class="paragraph">
<p>This isn&#8217;t to say that mocks are always bad!
But just that, from experience,
attempting to use them as your primary tool for decoupling
your tests from external dependencies is not a viable solution;
it carries costs that often outweigh the benefits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
I&#8217;m glossing over the use of mocks in a "London-school"
    approach to TDD. See
    <a href="https://www.obeythetestinggoat.com/book/appendix_purist_unit_tests.html">Online Appendix: Test Isolation and "Listening to Your Tests"</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_actual_solutions_are_architectural">The Actual Solutions Are Architectural</h3>
<div class="paragraph">
<p>The actual solution to the problem isn&#8217;t obvious from where we&#8217;re standing,
but it lies in rethinking the architecture of our application.
In brief, if we can <em>decouple</em> the core business logic of our application
from its dependencies, then we can write true unit tests for it,
that do not depend on those, um, dependencies.</p>
</div>
<div class="paragraph">
<p>Integration tests are most necessary at the <em>boundaries</em> of a system&#8212;&#8203;at
the points where our code integrates with external systems,
like the database, filesystem, network, or a UI.
Similarly, it&#8217;s at the boundaries that the downsides of test isolation and
mocks are at their worst, because it&#8217;s at the boundaries that you&#8217;re most
likely to be annoyed if your tests are tightly coupled to an implementation,
or to need more reassurance that things are integrated properly.</p>
</div>
<div class="paragraph">
<p>Conversely, code at the <em>core</em> of our application&#8212;&#8203;code
that&#8217;s purely concerned with our business domain and business rules,
code that&#8217;s entirely under our control&#8212;&#8203;has no intrinsic need
for integration tests.</p>
</div>
<div class="paragraph">
<p>So the way to get what we want is to minimise the amount of our code
that has to deal with boundaries.
Then we test our core business logic with unit tests,
and test the rest with integration and functional tests.</p>
</div>
<div class="paragraph">
<p>But how do we do that?</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Time for a Plug!  Read more in "Cosmic Python"</div>
<div class="paragraph">
<p>As I arrived at the end of writing this book,
I realised that I was going to have to learn about these architectural solutions,
and it was at MADE.com that I met Bob Gregory who was to become my co-author.
There we explored "ports and adapters" and related architectures,
which were quite rare at the time in the Python World.</p>
</div>
<div class="paragraph">
<p>So if you&#8217;d like a take on these architectural patterns
with a Pythonic twist,
check out <a href="https://www.cosmicpython.com">Architecture Patterns with Python</a>,
which we subtitled "Cosmic Python",
because "Cosmos" is the opposite of "Chaos", in Greek.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ports_and_adaptershexagonalonionclean_architecture">Ports and Adapters/Hexagonal/Onion/Clean Architecture</h4>
<div class="paragraph">
<p>The classic solutions to this problem from the OO world
come under different names, but they&#8217;re all variations on the same trick:
identifying the boundaries, creating an interface to define that boundary,
and then using that interface at test-time to swap out fake versions of your real dependencies.</p>
</div>
<div class="paragraph">
<p>Steve Freeman and Nat Pryce, in their book
<a href="/book/bibliography.html#GOOSGBT"><em>Growing Object-Oriented Software, Guided by Tests</em></a>,
call this approach "Ports and Adapters" (see <a href="#ports-and-adapters">Ports and Adapters (diagram by Nat Pryce)</a>).</p>
</div>
<div id="ports-and-adapters" class="imageblock">
<div class="content">
<img src="images/tdd3_2702.png" alt="Illustration of ports and adapaters architecture, with isolated core and integration points">
</div>
<div class="title">Figure 2. Ports and Adapters (diagram by Nat Pryce)</div>
</div>
<div class="paragraph">
<p>This pattern, or variations on it, are known as
"Hexagonal Architecture" (by Alistair Cockburn),
"Clean Architecture" (by Robert C. Martin, aka Uncle Bob),
or "Onion Architecture" (by Jeffrey Palermo).</p>
</div>
</div>
<div class="sect3">
<h4 id="_functional_core_imperative_shell">Functional Core, Imperative Shell</h4>
<div class="paragraph">
<p>Gary Bernhardt pushes this further,
recommending an architecture he calls "Functional Core, Imperative Shell",
whereby the "shell" of the application,
the place where interaction with boundaries happens,
follows the imperative programming paradigm, and can be tested by integration tests,
functional tests, or even (gasp!) not at all, if it&#8217;s kept minimal enough.</p>
</div>
<div class="paragraph">
<p>But the core of the application is actually written
following the functional programming paradigm
(complete with the "no side effects" corollary),
which allows fully isolated, "pure" unit tests, <em>without any mocks or fakes</em>.</p>
</div>
<div class="paragraph">
<p>Check out Gary&#8217;s presentation titled
<a href="https://www.youtube.com/watch?v=eOYal8elnZk">"Boundaries"</a> for more on this
approach.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_central_conceit_these_architectures_are_better">The Central Conceit: These Architectures are "Better"</h4>
<div class="paragraph">
<p>These patterns do not come for free!
Introducing the extra indirection and abstraction can add complexity to your code.
In fact, the creator of Rails, David Heinemeier Hansson,
has a famous blog post where he describes these architectures as
<a href="https://dhh.dk/2014/test-induced-design-damage.html">test-induced design damage</a>.
That post eventually led to quite a thoughtful and nuanced discussion between DHH,
Martin Fowler and Kent Beck,
which you can follow <a href="https://martinfowler.com/articles/is-tdd-dead/">here</a>.</p>
</div>
<div class="paragraph">
<p>Like any technique, these patterns can be misused,
but I wanted to make the case for their upside:
by making our software more testable,
we also make it more modular and maintainable.
We are forced to clearly separate our concerns,
and we make it easier to do things like upgrade our infrastructure when we need to.
This is the place where the "improved design" desideratum comes in.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Making our software more testable,
  also often leads to a better design.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Testing In Production</div>
<div class="paragraph">
<p>I should also make a brief mention of the power of observability and monitoring.</p>
</div>
<div class="paragraph">
<p>Kent Beck tells a story about his first few weeks at Facebook,
when one of the first tests he wrote turned out to be flaky in the build.
Someone just deleted it.  Shocked and asking why,
he was told "We know production is up. Your test is just producing noise, we don&#8217;t need it".
<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p>
</div>
<div class="paragraph">
<p>Facebook has such confidence in its production monitoring and observability,
that it can provide them most of the feedback they need about whether the system is working.</p>
</div>
<div class="paragraph">
<p>Not everywhere is Facebook!  But it&#8217;s a good indication that automated tests
aren&#8217;t the be-all and end-all.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_hardest_part_knowing_when_to_make_the_switch">The Hardest Part: Knowing When to Make the Switch</h3>
<div id="frog_in_a_pot" class="imageblock">
<div class="content">
<img src="images/tdd3_2703.png" alt="An illustration of a frog being slowly boiled in a pan">
</div>
<div class="title">Figure 3. When is it Time to Hop Out?</div>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: update image</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For small to medium-sized applications, as we&#8217;ve seen, the Django test runner
and the integration tests it encourages us to write are just fine.
The problem is knowing when it&#8217;s time to make the change
to a more decoupled architecture, and start striving explicitly for the Test Pyramid.</p>
</div>
<div class="paragraph">
<p>It&#8217;s hard to give good advice here,
since I&#8217;ve only experienced environments where either someone else made the decision
before I joined, or the company is already struggling with a point where it&#8217;s
(at least arguably) too late.</p>
</div>
<div class="paragraph">
<p>One thing to bear in mind, though, is that the longer you leave it, the harder it is.
Another is that because the pain is only going to set in gradually,
like the apocryphal boiled frogs, you&#8217;re unlikely to notice
until you&#8217;re past the "perfect" moment to switch.
And on top of that, it&#8217;s <em>never</em> going to be a convenient time to switch.
This is one of those things, like tech debt,
that are always going to struggle to justify themselves in the face of more
immediate priorities.</p>
</div>
<div class="paragraph">
<p>So perhaps one strategy would be an Odysseus pact,
tie yourself to the mast, and make a commitment&#8212;&#8203;while the tests are still fast&#8212;&#8203;to
set a "red line" for when to switch.
For example: "if the tests ever take more than 10 seconds to run locally,
then it&#8217;s time to rethink the architecture".</p>
</div>
<div class="paragraph">
<p>I&#8217;m not saying 10 seconds is the right number by the way.
I know plenty of people who are perfectly happy to wait 30 seconds.
And I know Gary Bernhardt, for one, would get very nervous
at a test suite that takes more than 100ms.
But I think the idea of drawing that line in the sand, wherever it is,
<em>before</em> you get there, might be a good way to fight the "boiled frog" problem.</p>
</div>
<div class="paragraph">
<p>Failing all of that, if the best time to make the change was "ages ago",
then the second best time is "right now".</p>
</div>
<div class="paragraph">
<p>Other than that I can only wish you good luck,
and hope that by warning you of the dangers,
you&#8217;ll keep an eye on your test suite,
and spot the problems before they get too large.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wrap_up">Wrap-Up</h3>
<div class="paragraph">
<p>In this book, I&#8217;ve been able to show you how to use TDD,
and talk a bit about why we do it, and what makes a good test,
but we&#8217;re inevitably limited by the scope of the project.
What that&#8217;s meant is that some of the more advanced uses of TDD,
particularly the interplay between testing and architecture,
have been beyond the scope of this book.</p>
</div>
<div class="paragraph">
<p>But I hope that this chapter has been a bit a guide to find your way
around that topic as your career progresses.</p>
</div>
<div class="sect3">
<h4 id="_further_reading">Further Reading</h4>
<div class="paragraph">
<p>A few places to go for more inspiration:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fast Test, Slow Test and Boundaries</dt>
<dd>
<p>Gary Bernhardt&#8217;s talks from Pycon
<a href="https://www.youtube.com/watch?v=RAxiiRPHS9k">2012</a> and
<a href="https://www.youtube.com/watch?v=eOYal8elnZk">2013</a>.  His
<a href="http://www.destroyallsoftware.com">screencasts</a> are also well worth a look.</p>
</dd>
<dt class="hdlist1">Inverting the Pyramid</dt>
<dd>
<p><a href="http://watirmelon.com/tag/testing-pyramid/">A visual metaphor</a>
for what to do with a project like ours would end up,
with too many slow tests and not enough fast ones.</p>
</dd>
<dt class="hdlist1">Integration tests are a scam</dt>
<dd>
<p>J.B. Rainsberger has a
<a href="http://blog.thecodewhisperer.com/2010/10/16/integrated-tests-are-a-scam/">famous rant</a>
about the way integration tests will ruin your life.footnote:[
Rainsberger actually distinguishes "integrated" tests from integration tests:
integrated test is any test that&#8217;s not fully isolated from things outside
the unit under test.[
Then check out a couple of follow-up posts, particularly
<a href="http://www.jbrains.ca/permalink/using-integration-tests-mindfully-a-case-study">this
defence of acceptance tests</a>, and
<a href="http://www.jbrains.ca/permalink/part-2-some-hidden-costs-of-integration-tests">this
analysis of how slow tests kill productivity</a>.
</p>
</dd>
<dt class="hdlist1">Ports and Adapters</dt>
<dd>
<p>Steve Freeman and Nat Pryce wrote about this in <a href="/book/bibliography.html#GOOSGBT">their book</a>.
You can also catch a good discussion in
<a href="http://vimeo.com/83960706">this talk</a>.
See also
<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">Uncle
Bob&#8217;s description of the clean architecture</a>, and
<a href="http://alistair.cockburn.us/Hexagonal+architecture">Alistair Cockburn
coining the term "hexagonal architecture"</a>.</p>
</dd>
<dt class="hdlist1">The Test-Double testing wiki</dt>
<dd>
<p>Justin Searls&#8217;s online resource is a great source of definitions
and discussions of testing pros and cons,
and arrives at its own conclusions of the right way to do things:
<a href="https://github.com/testdouble/contributing-tests/wiki/Test-Driven-Development">testing wiki</a>.</p>
</dd>
<dt class="hdlist1">Fowler on Unit tests</dt>
<dd>
<p>Martin Fowler (author of <em>Refactoring</em>)
<a href="http://martinfowler.com/bliki/UnitTest.html">balanced and pragmatic tour</a>
of what unit tests are, and of the tradeoffs around speed.</p>
</dd>
<dt class="hdlist1">A Take From the World of Functional Programming</dt>
<dd>
<p>"Grokking Simplicity" by Eric Normand
explores the idea of "Functional Core, Imperative Shell".
Don&#8217;t worry, you don&#8217;t need a crazy FP language like Haskell or Clojure to understand it,
it&#8217;s written in perfectly sensible JavaScript.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Happy testing!</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Some people says it takes at least 15 minutes to get back into the flow state. In my experience, that&#8217;s overblown, and I sometimes wonder if it&#8217;s thanks to TDD. I think TDD reduces the cognitive load of programming. By breaking our work down into small increments, by simplifying our thinking "what&#8217;s the current failing test? what&#8217;s the simplest code I can write to make it pass?", it&#8217;s often actually quite easy to context-switch back into coding. Maybe it&#8217;s less true for the times when we&#8217;re doing design work and thinking about what the abstractions in our code should be thogh. But also there&#8217;s absolutely no hope for you if you&#8217;ve gone off to check social media while your tests run. See you in 20-minutes to an hour!
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. There&#8217;s a transcript of this story here: <a href="https://softwareengineeringdaily.com/wp-content/uploads/2019/08/SEDFB15-Facebook-Process-Kent-Beck.pdf" class="bare">https://softwareengineeringdaily.com/wp-content/uploads/2019/08/SEDFB15-Facebook-Process-Kent-Beck.pdf</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
License: Creative Commons <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode">CC-BY-NC-ND</a>. Last updated: 2025-07-28 10:14:18 +0100
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = 'chapter_27_hot_lava';
    };
    
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//obeythetestinggoat.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>