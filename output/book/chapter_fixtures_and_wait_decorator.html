<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Test Fixtures and a Decorator for Explicit Waits</title>
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
      var subheaders = document.getElementsByClassName('sectlevel2');
      var section;
      for (var i=0; i<subheaders.length; i++) {
        section = subheaders[i];
        if (section.innerHTML.indexOf(window.location.pathname) === -1) {
          section.style.display = 'none';
        } else {
          section.scrollIntoView && section.scrollIntoView();
        }
      }

    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_fixtures_and_wait_decorator">Test Fixtures and a Decorator for Explicit Waits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have a functional authentication system, we want to use it to
identify users, and be able to show them all the lists they have created.</p>
</div>
<div class="paragraph">
<p>To do that, we&#8217;re going to have to write FTs that have a logged-in user. Rather
than making each test go through the (time-consuming) login email dance, we
want to be able to skip that part.</p>
</div>
<div class="paragraph">
<p>This is about separation of concerns.  Functional tests aren&#8217;t like unit tests,
in that they don&#8217;t usually have a single assertion. But, conceptually, they
should be testing a single thing.  There&#8217;s no need for every single FT to test
the login/logout mechanisms. If we can figure out a way to "cheat" and skip
that part, we&#8217;ll spend less time waiting for duplicated test paths.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t overdo de-duplication in FTs.  One of the benefits of an FT is that
     it can catch strange and unpredictable interactions between different
     parts of your application.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This chapter has only just been rewritten for the new edition, so let me
    know via <a href="mailto:obeythetestinggoat@gmail.com">obeythetestinggoat@gmail.com</a> if you spot any problems or have any
    suggestions for improvement!
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_skipping_the_login_process_by_pre_creating_a_session">Skipping the Login Process by Pre-creating a Session</h3>
<div class="paragraph">
<p>It&#8217;s quite common for a user to return to a site and still have a cookie, which
means they are "pre-authenticated", so this isn&#8217;t an unrealistic cheat at all.
Here&#8217;s how you can set it up:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/test_my_lists.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.conf</span> <span class="keyword">import</span> <span class="include">settings</span>
<span class="keyword">from</span> <span class="include">django.contrib.auth</span> <span class="keyword">import</span> <span class="include">BACKEND_SESSION_KEY</span>, <span class="include">SESSION_KEY</span>, <span class="include">get_user_model</span>
<span class="keyword">from</span> <span class="include">django.contrib.sessions.backends.db</span> <span class="keyword">import</span> <span class="include">SessionStore</span>
<span class="keyword">from</span> .base <span class="keyword">import</span> <span class="include">FunctionalTest</span>
User = get_user_model()


<span class="keyword">class</span> <span class="class">MyListsTest</span>(FunctionalTest):

    <span class="keyword">def</span> <span class="function">create_pre_authenticated_session</span>(<span class="predefined-constant">self</span>, email):
        user = User.objects.create(email=email)
        session = SessionStore()
        session[SESSION_KEY] = user.pk <i class="conum" data-value="1"></i><b>(1)</b>
        session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[<span class="integer">0</span>]
        session.save()
        <span class="comment">## to set a cookie we need to first visit the domain.</span>
        <span class="comment">## 404 pages load the quickest!</span>
        <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.live_server_url + <span class="string"><span class="delimiter">"</span><span class="content">/404_no_such_url/</span><span class="delimiter">"</span></span>)
        <span class="predefined-constant">self</span>.browser.add_cookie(<span class="predefined">dict</span>(
            name=settings.SESSION_COOKIE_NAME,
            value=session.session_key, <i class="conum" data-value="2"></i><b>(2)</b>
            path=<span class="string"><span class="delimiter">'</span><span class="content">/</span><span class="delimiter">'</span></span>,
        ))</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We create a session object in the database.  The session key is the
primary key of the user object (which is actually the user&#8217;s email address).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We then add a cookie to the browser that matches the session on the
server&#8212;&#8203;on our next visit to the site, the server should recognise
us as a logged-in user.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that, as it is, this will only work because we&#8217;re using
<code>LiveServerTestCase</code>, so the <code>User</code> and <code>Session</code> objects we create will end up in
the same database as the test server.  Later we&#8217;ll need to modify it so that it
works against the database on the staging server too.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Django Sessions: How a User&#8217;s Cookies Tell the Server She Is Authenticated</div>
<div class="paragraph">
<p><em>Being an attempt to explain sessions, cookies, and authentication in Django.</em></p>
</div>
<div class="paragraph">
<p>Because HTTP is stateless, servers need a way of recognising different clients
with <em>every single request</em>. IP addresses can be shared, so the usual
solution is to give each client a unique session ID, which it will store in a
cookie, and submit with every request.  The server will store that ID somewhere
(by default, in the database), and then it can recognise each request that
comes in as being from a particular client.</p>
</div>
<div class="paragraph">
<p>If you log in to the site using the dev server, you can actually take a look at
your session ID by hand if you like.  It&#8217;s stored under the key <code>sessionid</code> by
default. See <a href="#session-cookie-screenshot">Examining the session cookie in the Debug toolbar</a>.</p>
</div>
<div id="session-cookie-screenshot" class="imageblock">
<div class="content">
<img src="images/twp2_2001.png" alt="twp2 2001">
</div>
<div class="title">Figure 1. Examining the session cookie in the Debug toolbar</div>
</div>
<div class="paragraph">
<p>These session cookies are set for all visitors to a Django site, whether
they&#8217;re logged in or not.</p>
</div>
<div class="paragraph">
<p>When we want to recognise a client as being a logged-in and authenticated user,
again, rather asking the client to send their username and password with every
single request, the server can actually just mark that client&#8217;s session as
being an authenticated session, and associate it with a user ID in its
database.</p>
</div>
<div class="paragraph">
<p>A session is a dictionary-like data structure, and the user ID is stored under
the key given by <code>django.contrib.auth.SESSION_KEY</code>.  You can check this out
in a <span class="keep-together"><code>./manage.py</code></span> <code>shell</code> if you like:</p>
</div>
<div class="listingblock skipme small-code">
<div class="content">
<pre>$ <strong>python manage.py shell</strong>
[...]
In [1]: from django.contrib.sessions.models import Session

# substitute your session id from your browser cookie here
In [2]: session = Session.objects.get(
    session_key="8u0pygdy9blo696g3n4o078ygt6l8y0y"
)

In [3]: print(session.get_decoded())
{'_auth_user_id': '<a href="mailto:obeythetestinggoat@gmail.com">obeythetestinggoat@gmail.com</a>', '_auth_user_backend':
'accounts.authentication.PasswordlessAuthenticationBackend'}</pre>
</div>
</div>
<div class="paragraph">
<p>You can also store any other information you like on a user&#8217;s session,
as a way of temporarily keeping track of some state. This works for
non&#8211;logged-in users too.  Just use <code>request.session</code> inside any
view, and it works as a dict. There&#8217;s more information in the
<a href="https://docs.djangoproject.com/en/1.11/topics/http/sessions/">Django docs on
sessions</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_checking_that_it_works">Checking That It Works</h4>
<div class="paragraph">
<p>To check that it works, it would be good to use some of the code from our previous
test.  Let&#8217;s make a couple of functions called <code>wait_to_be_logged_in</code> and
<code>wait_to_be_logged_out</code>. To access them from a different test, we&#8217;ll need
to pull them up into <code>FunctionalTest</code>. We&#8217;ll also tweak them slightly so that
they can take an arbitrary email address as a parameter:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/base.py (ch18l002)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">FunctionalTest</span>(StaticLiveServerTestCase):
    [...]

    <span class="keyword">def</span> <span class="function">wait_to_be_logged_in</span>(<span class="predefined-constant">self</span>, email):
        <span class="predefined-constant">self</span>.wait_for(
            <span class="keyword">lambda</span>: <span class="predefined-constant">self</span>.browser.find_element_by_link_text(<span class="string"><span class="delimiter">'</span><span class="content">Log out</span><span class="delimiter">'</span></span>)
        )
        navbar = <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.navbar</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertIn(email, navbar.text)


    <span class="keyword">def</span> <span class="function">wait_to_be_logged_out</span>(<span class="predefined-constant">self</span>, email):
        <span class="predefined-constant">self</span>.wait_for(
            <span class="keyword">lambda</span>: <span class="predefined-constant">self</span>.browser.find_element_by_name(<span class="string"><span class="delimiter">'</span><span class="content">email</span><span class="delimiter">'</span></span>)
        )
        navbar = <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.navbar</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertNotIn(email, navbar.text)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hm, that&#8217;s not bad, but I&#8217;m not quite happy with the amount of duplication
of <code>wait_for</code> stuff in here.  Let&#8217;s make a note to come back to it, and
get these helpers working.</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Clean up wait_for stuff in base.py</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>First we use them in <em>test_login.py</em>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/test_login.py (ch18l003)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_can_get_email_link_to_log_in</span>(<span class="predefined-constant">self</span>):
        [...]
        <span class="comment"># she is logged in!</span>
        <span class="predefined-constant">self</span>.wait_to_be_logged_in(email=TEST_EMAIL)

        <span class="comment"># Now she logs out</span>
        <span class="predefined-constant">self</span>.browser.find_element_by_link_text(<span class="string"><span class="delimiter">'</span><span class="content">Log out</span><span class="delimiter">'</span></span>).click()

        <span class="comment"># She is logged out</span>
        <span class="predefined-constant">self</span>.wait_to_be_logged_out(email=TEST_EMAIL)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Just to make sure we haven&#8217;t broken anything, we rerun the login test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_login</strong>
[...]
OK</pre>
</div>
</div>
<div class="paragraph">
<p>And now we can write a placeholder for the "My Lists" test, to see if
our pre-authenticated session creator really does work:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/test_my_lists.py (ch18l004)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_logged_in_users_lists_are_saved_as_my_lists</span>(<span class="predefined-constant">self</span>):
        email = <span class="string"><span class="delimiter">'</span><span class="content">edith@example.com</span><span class="delimiter">'</span></span>
        <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.live_server_url)
        <span class="predefined-constant">self</span>.wait_to_be_logged_out(email)

        <span class="comment"># Edith is a logged-in user</span>
        <span class="predefined-constant">self</span>.create_pre_authenticated_session(email)
        <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.live_server_url)
        <span class="predefined-constant">self</span>.wait_to_be_logged_in(email)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That gets us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_my_lists</strong>
[...]
OK</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s a good place for a commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git add functional_tests</strong>
$ <strong>git commit -m "test_my_lists: precreate sessions, move login checks into base"</strong></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JSON Test Fixtures Considered Harmful</div>
<div class="paragraph">
<p>When we pre-populate the database with test data, as we&#8217;ve done here with the
<code>User</code> object and its associated <code>Session</code> object, what we&#8217;re doing is setting
up a "test fixture".</p>
</div>
<div class="paragraph">
<p>Django comes with built-in support for saving database objects as JSON (using
the <code>manage.py dumpdata</code>), and automatically loading them in your test runs
using the <code>fixtures</code> class attribute on <code>TestCase</code>.</p>
</div>
<div class="paragraph">
<p>More and more people are starting to say:
<a href="http://bit.ly/1kSTyrb">don&#8217;t use JSON fixtures</a>.
They&#8217;re a nightmare to maintain when your model changes.  Plus it&#8217;s difficult
for the reader to tell which of the many attribute values specified in the
JSON are critical for the behaviour under test, and which are just filler.
Finally, even if tests start out sharing fixtures, sooner or later one
test will want slightly different versions of the data, and you end up copying
the whole thing around to keep them isolated, and again it&#8217;s hard to tell
what&#8217;s relevant to the test and what is just happenstance.</p>
</div>
<div class="paragraph">
<p>It&#8217;s usually much more straightforward to just load the data directly
using the Django ORM.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Once you have more than a handful of fields on a model, and/or several
    related models, even using the ORM can be cumbersome.  In this case,
    there&#8217;s a tool that lots of people swear by called
    <a href="https://factoryboy.readthedocs.org/"><code>factory_boy</code></a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_our_final_explicit_wait_helper_a_wait_decorator">Our Final Explicit Wait Helper: A Wait Decorator</h3>
<div class="paragraph">
<p>We&#8217;ve used decorators a few times in our code so far, but it&#8217;s time to learn
how they actually work by making one of our own.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s imagine how we might want our decorator to work.  It would be
nice to be able to replace all the custom wait/retry/timeout logic in
<code>wait_for_row_in_list_table</code> and the inline <code>self.wait_fors</code> in the
<code>wait_to_be_logged_in/out</code>.   Something like this would look lovely:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/base.py (ch18l005)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@wait</span>
    <span class="keyword">def</span> <span class="function">wait_for_row_in_list_table</span>(<span class="predefined-constant">self</span>, row_text):
        table = <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_list_table</span><span class="delimiter">'</span></span>)
        rows = table.find_elements_by_tag_name(<span class="string"><span class="delimiter">'</span><span class="content">tr</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertIn(row_text, [row.text <span class="keyword">for</span> row <span class="keyword">in</span> rows])


    <span class="decorator">@wait</span>
    <span class="keyword">def</span> <span class="function">wait_to_be_logged_in</span>(<span class="predefined-constant">self</span>, email):
        <span class="predefined-constant">self</span>.browser.find_element_by_link_text(<span class="string"><span class="delimiter">'</span><span class="content">Log out</span><span class="delimiter">'</span></span>)
        navbar = <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.navbar</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertIn(email, navbar.text)


    <span class="decorator">@wait</span>
    <span class="keyword">def</span> <span class="function">wait_to_be_logged_out</span>(<span class="predefined-constant">self</span>, email):
        <span class="predefined-constant">self</span>.browser.find_element_by_name(<span class="string"><span class="delimiter">'</span><span class="content">email</span><span class="delimiter">'</span></span>)
        navbar = <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.navbar</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertNotIn(email, navbar.text)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Are you ready to dive in?  Although decorators are quite difficult to
wrap your head around (I know it took me a long time before I was
comfortable with them, and I still have to think about them quite
carefully whenever I make one), the nice thing is that we&#8217;ve already
dipped our toes into functional programming in our <code>self.wait_for</code>
helper function.  That&#8217;s a function that takes another function as
an argument, and a decorator is the same.  The difference is that the
decorator doesn&#8217;t actually execute any code itself&#8212;it returns a
modified version of the function that it was given.</p>
</div>
<div class="paragraph">
<p>Our decorator wants to return a new function which will keep calling
the function it was given, catching our usual exceptions, until a
timeout occurs.  Here&#8217;s a first cut:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/base.py (ch18l006)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">wait</span>(fn):  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">def</span> <span class="function">modified_fn</span>():  <i class="conum" data-value="3"></i><b>(3)</b>
        start_time = time.time()
        <span class="keyword">while</span> <span class="predefined-constant">True</span>:  <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="keyword">try</span>:
                <span class="keyword">return</span> fn()  <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="keyword">except</span> (<span class="exception">AssertionError</span>, WebDriverException) <span class="keyword">as</span> e:  <i class="conum" data-value="4"></i><b>(4)</b>
                <span class="keyword">if</span> time.time() - start_time &gt; MAX_WAIT:
                    <span class="keyword">raise</span> e
                time.sleep(<span class="float">0.5</span>)
    <span class="keyword">return</span> modified_fn  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A decorator is a way of modifying a function; it takes a function
as an <span class="keep-together">argument...</span></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and returns another function as the modified (or "decorated") version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here&#8217;s where we create our modified function.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And here&#8217;s our familiar loop, which will keep going, catching the usual
exceptions, until our timeout expires.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>And as always, we call our function and return immediately if there are
no <span class="keep-together">exceptions</span>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That&#8217;s <em>almost</em> right, but not quite;  try running it?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_my_lists</strong>
[...]
    self.wait_to_be_logged_out(email)
TypeError: modified_fn() takes 0 positional arguments but 2 were given</pre>
</div>
</div>
<div class="paragraph">
<p>Unlike in <code>self.wait_for</code>, the decorator is being applied to functions
that have <span class="keep-together">arguments</span>:</p>
</div>
<div class="exampleblock sourcecode currentcontents">
<div class="title">functional_tests/base.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@wait</span>
    <span class="keyword">def</span> <span class="function">wait_to_be_logged_in</span>(<span class="predefined-constant">self</span>, email):
        <span class="predefined-constant">self</span>.browser.find_element_by_link_text(<span class="string"><span class="delimiter">'</span><span class="content">Log out</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>wait_to_be_logged_in</code> takes <code>self</code> and <code>email</code> as positional arguments.
But when it&#8217;s decorated, it&#8217;s replaced with <code>modified_fn</code>, which takes
no arguments.  How do we magically make it so our <code>modified_fn</code> can handle
the same arguments as whatever <code>fn</code> the decorator gets given has?</p>
</div>
<div class="paragraph">
<p>The answer is a bit of Python magic, <code>*args</code> and <code>**kwargs</code>, more formally
known as
<a href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments">"variadic
arguments"</a>, apparently (I only just learned that):</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/base.py (ch18l007)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">wait</span>(fn):
    <span class="keyword">def</span> <span class="function">modified_fn</span>(*args, **kwargs):  <i class="conum" data-value="1"></i><b>(1)</b>
        start_time = time.time()
        <span class="keyword">while</span> <span class="predefined-constant">True</span>:
            <span class="keyword">try</span>:
                <span class="keyword">return</span> fn(*args, **kwargs)  <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="keyword">except</span> (<span class="exception">AssertionError</span>, WebDriverException) <span class="keyword">as</span> e:
                <span class="keyword">if</span> time.time() - start_time &gt; MAX_WAIT:
                    <span class="keyword">raise</span> e
                time.sleep(<span class="float">0.5</span>)
    <span class="keyword">return</span> modified_fn</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>*args</code> and <code>**kwargs</code>, we specify that <code>modified_fn</code> may take
any arbitrary positional and keyword arguments.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As we&#8217;ve captured them in the function definition, we make sure to
pass those same arguments to <code>fn</code> when we actually call it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the fun things this can be used for is to make a decorator that changes
the arguments of a function.  But we won&#8217;t get into that now.  The main thing
is that our decorator now works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_my_lists</strong>
[...]
OK</pre>
</div>
</div>
<div class="paragraph">
<p>And do you know what&#8217;s truly satisfying?  We can use our <code>wait</code> decorator
for our <code>self.wait_for</code> helper as well!  Like this:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/base.py (ch18l008)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="decorator">@wait</span>
    <span class="keyword">def</span> <span class="function">wait_for</span>(<span class="predefined-constant">self</span>, fn):
        <span class="keyword">return</span> fn()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Lovely!  Now all our wait/retry logic is encapsulated in a single place,
and we have a nice easy way of applying those waits, either inline in our
FTs using <code>self.wait_for</code>, or on any helper function using the <code>@wait</code>
decorator.</p>
</div>
<div class="paragraph">
<p>In the next chapter we&#8217;ll try to deploy our code to staging, and
use the pre-authenticated session fixtures on the server.  As we&#8217;ll see
it&#8217;ll help us catch a little bug or two!</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Lessons Learned</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Decorators are nice</dt>
<dd>
<p>Decorators can be a great way of abstracting out different levels of
concerns.  They let us write our test assertions without having to
think about waits at the same time.</p>
</dd>
<dt class="hdlist1">De-duplicate your FTs, with caution</dt>
<dd>
<p>Every single FT doesn&#8217;t need to test every single part of your application.
In our case, we wanted to avoid going through the full login process for
every FT that needs an authenticated user, so we used a test fixture to
"cheat" and skip that part. You might find other things you want to skip
in your FTs.  A word of caution, however: functional tests are there to
catch unpredictable interactions between different parts of your
application, so be wary of pushing de-duplication to the extreme.</p>
</dd>
<dt class="hdlist1">Test fixtures</dt>
<dd>
<p>Test fixtures refers to test data that needs to be set up as a precondition
before a test is run&#8212;&#8203;often this means populating the database with some
information, but as we&#8217;ve seen (with browser cookies), it can involve other
types of preconditions.</p>
</dd>
<dt class="hdlist1">Avoid JSON fixtures</dt>
<dd>
<p>Django makes it easy to save and restore data from the database in JSON
format (and others) using the <code>dumpdata</code> and <code>loaddata</code> management
commands.  <span class="keep-together">Most people</span> recommend against using these for test fixtures,
as they are painful to manage when your database schema changes. Use the
ORM, or a tool like <a href="https://factoryboy.readthedocs.org/"><code>factory_boy</code></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-07-04 10:59:52 BST
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = 'chapter_fixtures_and_wait_decorator';
    };
    
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//obeythetestinggoat.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>