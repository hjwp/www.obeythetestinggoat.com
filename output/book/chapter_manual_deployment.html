<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Testing Deployment Using a Staging Site</title>
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
      var subheaders = document.getElementsByClassName('sectlevel2');
      var section;
      for (var i=0; i<subheaders.length; i++) {
        section = subheaders[i];
        if (section.innerHTML.indexOf(window.location.pathname) === -1) {
          section.style.display = 'none';
        } else {
          section.scrollIntoView && section.scrollIntoView();
        }
      }

    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_manual_deployment">Testing Deployment Using a Staging Site</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Is all fun and game until you are need of put it in production.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; <a href="http://bit.ly/2uhCXnH">Devops Borat</a>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s
time to deploy the first version of our site and make it public.  They say
that if you wait until you feel ready to ship, then you&#8217;ve waited too long.</p>
</div>
<div class="paragraph">
<p>Is our site usable?  Is it better than nothing? Can we make lists on it? Yes,
yes, yes.</p>
</div>
<div class="paragraph">
<p>No, you can&#8217;t log in yet.  No, you can&#8217;t mark tasks as completed.  But do we
really need any of that stuff? Not really&#8212;&#8203;and you can never be sure what
your users are <em>actually</em> going to do with your site once they get their
hands on it. We think our users want to use the site for to-do lists, but maybe
they actually want to use it to make "top 10 best fly-fishing spots" lists, for
which you don&#8217;t need any kind of &#8220;mark completed&#8221; function. We won&#8217;t know
until we put it out there.</p>
</div>
<div class="paragraph">
<p>In this chapter we&#8217;re going to go through and actually deploy our site to a
real, live web server.</p>
</div>
<div class="paragraph">
<p>You might be tempted to skip this chapter&#8212;&#8203;there&#8217;s lots of daunting stuff
in it, and maybe you think this isn&#8217;t what you signed up for. But I <em>strongly</em>
urge you to give it a go.  This is one of the sections of the book I&#8217;m most
pleased with, and it&#8217;s one that people often write to me saying they were
really glad they stuck through it.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve never done a server deployment before, it will demystify a whole
world for you, and there&#8217;s nothing like the feeling of seeing your site live on
the actual internet. Give it a buzzword name like "DevOps" if that&#8217;s what it
takes to convince you it&#8217;s worth it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Why not ping me a note once your site is live on the web, and send me
    the URL? It always gives me a warm and fuzzy feeling&#8230;&#8203;
    <a href="mailto:obeythetestinggoat@gmail.com">obeythetestinggoat@gmail.com</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_tdd_and_the_danger_areas_of_deployment">TDD and the Danger Areas of Deployment</h3>
<div class="paragraph">
<p>Deploying
a site to a live web server can be a tricky topic.  Oft-heard is the
forlorn cry <em>"but it works on my machine!"</em></p>
</div>
<div class="paragraph">
<p>Some
of the danger areas of deployment include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Networking</dt>
<dd>
<p>Once we&#8217;re off our own machine, networking issues come in: making
sure the DNS service is routing our domain to the correct IP address
for our server, making sure our server is configured to listen to
traffic coming in from the world, making sure it&#8217;s using the right
ports, and making sure any firewalls n the way are configured to let
traffic through.</p>
</dd>
<dt class="hdlist1">Dependencies</dt>
<dd>
<p>We need to make sure that the packages our software relies on (Python,
Django, and so on) are installed on the server, and have the correct
versions.</p>
</dd>
<dt class="hdlist1">The database</dt>
<dd>
<p>There can be permissions and path issues, and we need to be careful about
preserving data between deploys.</p>
</dd>
<dt class="hdlist1">Static files (CSS, JavaScript, images, etc.)</dt>
<dd>
<p>Web servers usually need special
configuration for serving these.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>But there are solutions to all of these.  In order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using a <em>staging site</em>, on the same infrastructure as the production site,
can help us test out our deployments and get things right before we go to
the "real" site.</p>
</li>
<li>
<p>We can also <em>run our functional tests against the staging site</em>. That will
reassure us that we have the right code and packages on the server, and
since we now have a "smoke test" for our site layout, we&#8217;ll know that the
CSS is loaded correctly.</p>
</li>
<li>
<p>Just
like on our own PC, a <em>virtualenv</em> is useful on the server for
managing packages and dependencies when you might be running more than one
Python <span class="keep-together">application</span>.</p>
</li>
<li>
<p>And
finally, <em>automation, automation, automation</em>.  By using an automated
script to deploy new versions, and by using the same script to deploy to
staging <span class="keep-together">and production</span>, we can reassure ourselves that staging is as much
like live as
<span class="keep-together">possible</span>.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Over the next few pages I&#8217;m going to go through <em>a</em> deployment procedure.  It
isn&#8217;t meant to be the <em>perfect</em> deployment procedure, so please don&#8217;t take
it as being best practice, or a recommendation&#8212;&#8203;it&#8217;s meant to be an
illustration, to show the kinds of issues involved in deployment and where
testing fits in.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Deployment Chapters Overview</div>
<div class="paragraph">
<p>There&#8217;s lots of stuff in the next three chapters, so here&#8217;s an overview to help you
keep your bearings:</p>
</div>
<div class="paragraph">
<p><strong>This chapter: getting a manual deployment up and running</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adapt our FTs so they can run against a staging server.</p>
</li>
<li>
<p>Spin up a server, install all the required software on it, and point our
staging and live domains at it.</p>
</li>
<li>
<p>Upload our code to the server using Git.</p>
</li>
<li>
<p>Try and get a quick-and-dirty version of our site running on the staging domain
using the Django dev server.</p>
</li>
<li>
<p>Set up a virtualenv on the server and make sure the database and
static files are working.</p>
</li>
<li>
<p>As we go, we&#8217;ll keep running our FT, to tell us what&#8217;s working and what&#8217;s
not.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Next chapter: moving to a production-ready config</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Move from our quick-and-dirty version to a production-ready configuration;
stop using the Django dev server, use Nginx and Gunicorn as web serves,
configure efficient static file serving, set our app to start automatically
on boot, set <code>DEBUG</code> to <code>False</code>, and so on.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Third deployment chapter: automating the deployment</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Once we have a working config, we&#8217;ll write a script to automate the process
we&#8217;ve just been through manually, so that we can deploy our site
automatically in future.</p>
</li>
<li>
<p>Finally we&#8217;ll use this script to deploy the production version of our site
on its real domain.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_as_always_start_with_a_test">As Always, Start with a Test</h3>
<div class="paragraph">
<p>Let&#8217;s
adapt our functional tests slightly so that it can be run against
a staging site. We&#8217;ll do it by checking for an environment variable called
<code>STAGING_SERVER</code>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">functional_tests/tests.py (ch08l001)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">import</span> <span class="include">os</span>
[...]

<span class="keyword">class</span> <span class="class">NewVisitorTest</span>(StaticLiveServerTestCase):

    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.browser = webdriver.Firefox()
        staging_server = os.environ.get(<span class="string"><span class="delimiter">'</span><span class="content">STAGING_SERVER</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">if</span> staging_server:
            <span class="predefined-constant">self</span>.live_server_url = <span class="string"><span class="delimiter">'</span><span class="content">http://</span><span class="delimiter">'</span></span> + staging_server  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Do you remember I said that <code>LiveServerTestCase</code> had certain limitations?
Well, one is that it always assumes you want to use its own test server, which
it makes available at <code>self.live_server_url</code>.  I still want to be able to do
that sometimes, but I also want to be able to selectively tell it not to
bother, and to use a real server instead.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The way I decided to do it is using an environment variable called
<code>STAGING_SERVER</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here&#8217;s the hack: we replace <code>self.live_server_url</code> with the address of
our "real" server.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We test that said hack hasn&#8217;t broken anything by running the functional
tests <span class="keep-together">"normally"</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
Ran 3 tests in 8.544s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>And now we can try them against our staging server URL.  I&#8217;m planning to
host my staging server at <em>superlists-staging.ottg.eu</em>:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A clarification: in this chapter, we run tests <em>against</em> our staging
    server, not <em>on</em> our staging server.  So we run the tests from our own
    laptop, but they target the site that&#8217;s running on the server.
</td>
</tr>
</table>
</div>
<div class="listingblock small-code">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests</strong>

EEE
======================================================================
ERROR: test_can_start_a_list_for_one_user
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/functional_tests/tests.py", line 41, in
test_can_start_a_list_for_one_user
    self.browser.get(self.live_server_url)
[...]
selenium.common.exceptions.WebDriverException: Message: Reached error page: abo
ut:neterror?e=connectionFailure&amp;u=http%3A//superlists-staging.ottg.eu/&amp;c=UTF-8&amp;
f=regular&amp;d=Firefox%20can%27t%20establish%20a%20connection%20to%20the%20server%
20at%20superlists-staging.ottg.eu.


======================================================================
ERROR: test_layout_and_styling (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/functional_tests/tests.py", line 126, in
test_layout_and_styling
[...]
selenium.common.exceptions.WebDriverException: Message: Reached error page: abo
[...]


======================================================================
ERROR: test_multiple_users_can_start_lists_at_different_urls
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/functional_tests/tests.py", line 80, in
test_multiple_users_can_start_lists_at_different_urls
[...]
selenium.common.exceptions.WebDriverException: Message: Reached error page: abo
[...]

Ran 3 tests in 10.518s

FAILED (errors=3)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If, on Windows, you see an error saying something like
    "STAGING_SERVER is not recognized as a command", it&#8217;s probably because
    you&#8217;re not using Git-Bash.  Take another look at the
    &#8220;<a href="/book/pre-requisite-installations.html">[pre-requisites]</a>&#8221; section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can see that all the tests are failing, as expected, since I haven&#8217;t
actually set up my domain yet&#8201;&#8212;&#8201;Selenium reports that Firefox is seeing an
error and "cannot establish connection to the server" (depending on your
registrar, you might see content from its default landing page instead).</p>
</div>
<div class="paragraph">
<p>The
FT seems to be testing the right things though, so let&#8217;s commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git diff</strong> # should show changes to functional_tests.py
$ <strong>git commit -am "Hack FT runner to be able to test staging"</strong></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t use <code>export</code> to set the <em>STAGING_SERVER</em> environment variable;
    otherwise, all your subsequent test runs in that terminal will be against
    staging (and that can be very confusing if you&#8217;re not expecting it).
    Setting it explicitly inline each time you run the FTs is best.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_a_domain_name">Getting a Domain Name</h3>
<div class="paragraph">
<p>We&#8217;re
going to need a couple of domain names at this point in the book&#8212;&#8203;they
can both be subdomains of a single domain.  I&#8217;m going to use
<em>superlists.ottg.eu</em> and <em>superlists-staging.ottg.eu</em>.
If you don&#8217;t already own a domain, this is the time to register one! Again,
this is something I really want you to <em>actually</em> do.  If you&#8217;ve never
registered a domain before, just pick any old registrar and buy a cheap one&#8212;&#8203;it
should only cost you $5 or so, and you can even find free ones.
I promise seeing your site on a "real" website will be a thrill.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manually_provisioning_a_server_to_host_our_site">Manually Provisioning a Server to Host Our Site</h3>
<div class="paragraph">
<p>We
can separate out "deployment" into two tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Provisioning</em> a new server to be able to host the code</p>
</li>
<li>
<p><em>Deploying</em> a new version of the code to an existing server</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some people like to use a brand new server for every deployment&#8212;&#8203;it&#8217;s what we
do at PythonAnywhere.  That&#8217;s only necessary for larger, more complex sites
though, or major changes to an existing site. For a simple site like ours, it
makes sense to separate the two tasks.  And, although we eventually want both
to be completely automated, we can probably live with a manual provisioning
system for now.</p>
</div>
<div class="paragraph">
<p>As you go through this chapter, you should be aware that provisioning is
something that varies a lot, and that as a result there are few universal
best practices for deployment.  So, rather than trying to remember the
specifics of what I&#8217;m doing here, you should be trying to understand the
rationale, so that you can apply the same kind of thinking in the
specific future circumstances you encounter.</p>
</div>
<div class="sect3">
<h4 id="_choosing_where_to_host_our_site">Choosing Where to Host Our Site</h4>
<div class="paragraph">
<p>There
are loads of different solutions out there these days, but they broadly
fall into two camps:</p>
</div>
<div class="ulist pagebreak-before">
<ul>
<li>
<p>Running your own (possibly virtual) server</p>
</li>
<li>
<p>Using a Platform-As-A-Service (PaaS) offering like Heroku, OpenShift, or
<span class="keep-together">PythonAnywhere</span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Particularly
for small sites, a PaaS offers a lot of advantages, and I would
definitely recommend looking into them.  We&#8217;re not going to use a PaaS in this
book however, for several reasons.  Firstly, I have a conflict of interest, in
that I think PythonAnywhere is the best, but then again I would say that
because I work there.  Secondly, all the PaaS offerings are quite different,
and the procedures to deploy to each vary a lot&#8212;&#8203;learning about one doesn&#8217;t
necessarily tell you about the others. Any one of them might change their
process radically, or simply go out of business by the time you get to read
this book.</p>
</div>
<div class="paragraph">
<p>Instead, we&#8217;ll learn just a tiny bit of good old-fashioned server admin,
including SSH and web server config.  They&#8217;re unlikely to ever go away, and
knowing a bit about them will get you some respect from all the grizzled
dinosaurs out there.</p>
</div>
<div class="paragraph">
<p>What I have done is to try to set up a server in such a way that it&#8217;s a lot
like the environment you get from a PaaS, so you should be able to apply the
lessons we learn in the deployment section, no matter what provisioning
solution you choose.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spinning_up_a_server">Spinning Up a Server</h4>
<div class="paragraph">
<p>I&#8217;m not going to
dictate how you do this&#8212;&#8203;whether you choose Amazon AWS, Rackspace, Digital
Ocean, your own server in your own data centre or a Raspberry Pi in a cupboard
under the stairs, any solution should be fine, as long as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Your server is running Ubuntu 16.04 (aka "Xenial/LTS").</p>
</li>
<li>
<p>You have root access to it.</p>
</li>
<li>
<p>It&#8217;s on the public internet.</p>
</li>
<li>
<p>You can SSH into it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I&#8217;m recommending Ubuntu as a distro because it&#8217;s easy to get Python 3.6 on it
and it has some specific ways of configuring Nginx, which I&#8217;m going to make use
of next.  If you know what you&#8217;re doing, you can probably get away with using
something else, but you&#8217;re on your own.</p>
</div>
<div class="paragraph">
<p>If
you&#8217;ve never started a Linux server before and you have absolutely no idea
where to start, I wrote a
<a href="https://github.com/hjwp/Book-TDD-Web-Dev-Python/blob/master/server-quickstart.md">very brief guide on GitHub</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some
people get to this chapter, and are tempted to skip the domain bit,
    and the "getting a real server" bit, and just use a VM on their own PC.
    Don&#8217;t do this. It&#8217;s <em>not</em> the same, and you&#8217;ll have more difficulty
    following the instructions, which are complicated enough as it is.  If
    you&#8217;re worried about cost, dig around and you&#8217;ll find free options for
    both. Email me if you need further pointers; I&#8217;m always happy to help.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_user_accounts_ssh_and_privileges">User Accounts, SSH, and Privileges</h4>
<div class="paragraph">
<p>In these instructions, I&#8217;m assuming that you have a nonroot user account set
up that has "sudo" privileges, so whenever we need to do something that
requires root access, we use sudo, and I&#8217;m explicit about that in the various
instructions that follow.</p>
</div>
<div class="paragraph">
<p>My user is called "elspeth", but you can call yours whatever you like!</p>
</div>
</div>
<div class="sect3">
<h4 id="_installing_python_3_6">Installing Python 3.6</h4>
<div class="paragraph">
<p>Python
3.6 wasn&#8217;t available in the standard repositories on Ubuntu at the
time of writing, but the user-contributed
<a href="https://launchpad.net/~fkrull/+archive/ubuntu/deadsnakes">"Deadsnakes PPA"</a>
has it.  Here&#8217;s how we install it:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>sudo add-apt-repository ppa:deadsnakes/ppa</strong>
elspeth@server:$ <strong>sudo apt update</strong>
elspeth@server:$ <strong>sudo apt install python3.6 python3.6-venv</strong></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Look out for that <code>elspeth@server</code> in the command-line listings in this
    chapter. It indicates commands that must be run on the server, as opposed
    to commands you run on your own PC.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And while we&#8217;re at it, we&#8217;ll just make sure Git is installed too.</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>sudo apt install git</strong></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_domains_for_staging_and_live">Configuring Domains for Staging and Live</h4>
<div class="paragraph">
<p>We don&#8217;t want to be messing about with IP addresses all the time, so we should
point our staging and live domains to the server. At my registrar, the control
screens looked a bit like <a href="#registrar-control-screens">Domain setup</a>.</p>
</div>
<div id="registrar-control-screens" class="imageblock">
<div class="content">
<img src="images/twp2_0902.png" alt="Registrar control screens for two domains">
</div>
<div class="title">Figure 1. Domain setup</div>
</div>
<div class="paragraph">
<p>In
the DNS system, pointing a domain at a specific IP address is called an
"A-Record".  All registrars are slightly different, but a bit of clicking
around should get you to the right screen in yours.</p>
</div>
<div class="paragraph">
<p>DNS records take some time to "propagate" around the world (it&#8217;s controlled
by a setting called "TTL", Time To Live), so once you&#8217;ve set up your A-record,
you can check its progress on a "propagation checking" service like this one:</p>
</div>
<div class="paragraph">
<p><a href="https://www.whatsmydns.net/#A/superlists-staging.ottg.eu" class="bare">https://www.whatsmydns.net/#A/superlists-staging.ottg.eu</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_our_code_manually">Deploying Our Code Manually</h3>
<div class="paragraph">
<p>The
next step is to get a basic copy of the staging site up and running
As we do so, we&#8217;re starting to move into doing "deployment" rather than
provisioning, so we should be thinking about how we can automate the process as
we go.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One rule of thumb for distinguishing provisioning from deployment is
    that you tend to need root permissions for the former, but you don&#8217;t for
    the latter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We need a directory for the source to live in.  We&#8217;ll put it somewhere
in the home folder of our nonroot user; in my case it would be at
<em>/home/elspeth</em> (this is likely to be the setup on any shared hosting system,
but you should always run your web apps as a nonroot user, in any case). I&#8217;m
going to set up my sites like this:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>/home/elspeth
&#9500;&#9472;&#9472; sites
&#9474;&#160;&#160; &#9500;&#9472;&#9472; www.live.my-website.com
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; db.sqlite3
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; manage.py
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; [etc...]
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; static
&#9474;&#160;&#160; &#9474;    &#9474;    &#9500;&#9472;&#9472; base.css
&#9474;&#160;&#160; &#9474;    &#9474;    &#9500;&#9472;&#9472; [etc...]
&#9474;&#160;&#160; &#9474;    &#9492;&#9472;&#9472; virtualenv
&#9474;&#160;&#160; &#9474;         &#9500;&#9472;&#9472; lib
&#9474;&#160;&#160; &#9474;         &#9500;&#9472;&#9472; [etc...]
&#9474;&#160;&#160; &#9474;
&#9474;&#160;&#160; &#9500;&#9472;&#9472; www.staging.my-website.com
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; db.sqlite3
&#9474;&#160;&#160; &#9474;    &#9500;&#9472;&#9472; [etc...]</pre>
</div>
</div>
<div class="paragraph">
<p>Each site (staging, live, or any other website) has its own folder, which
will contain a checkout of the source code (managed by git), along with the
database, static files and virtualenv (managed separately).</p>
</div>
<div class="paragraph">
<p>To get our code onto the server, we&#8217;ll use Git and go via one of the
code-sharing sites.  If you haven&#8217;t already, push your code up to GitHub,
BitBucket, or similar.  They all have excellent instructions for beginners on
how to do that.</p>
</div>
<div class="paragraph">
<p>Here
are some bash commands that will set this all up. If you&#8217;re not familiar
with it, note the <code>export</code> command which lets me set up a "local variable"
in bash:</p>
</div>
<div class="listingblock server-commands small-code">
<div class="content">
<pre>elspeth@server:$ <strong>export SITENAME=superlists-staging.ottg.eu</strong>
# you should replace the URL in the next line with the URL for your own repo
elspeth@server:$ <strong>git clone https://github.com/hjwp/book-example.git ~/sites/$SITENAME</strong>
Resolving deltas: 100% [...]</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A bash variable defined using <code>export</code> only lasts as long as that console
    session. If you log out of the server and log back in again, you&#8217;ll need to
    redefine it. It&#8217;s devious because Bash won&#8217;t error, it will just substitute
    the empty string for the variable, which will lead to weird results&#8230;&#8203;if in
    doubt, do a quick <strong><code>echo $SITENAME</code></strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we&#8217;ve got the site installed, let&#8217;s just try running the dev server&#8212;&#8203;this
is a smoke test, to see if all the moving parts are connected:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ $ <strong>cd ~/sites/$SITENAME</strong>
$ <strong>python manage.py runserver</strong>
Traceback (most recent call last):
  File "manage.py", line 8, in &lt;module&gt;
    from django.core.management import execute_from_command_line
ImportError: No module named <em>django</em>
[...]
ImportError: Couldn't import Django. Are you sure it's installed and available
on your PYTHONPATH environment variable? Did you forget to activate a virtual
environment?</pre>
</div>
</div>
<div class="paragraph">
<p>Ah. Django isn&#8217;t installed on the server.</p>
</div>
<div class="sect3">
<h4 id="_creating_a_virtualenv_on_the_server_using_requirements_txt">Creating a Virtualenv on the server Using requirements.txt</h4>
<div class="paragraph">
<p>Just
like on our own machine, a virtualenv is useful on the server to make
sure we have full control over the packages installed for a particular
project.  It can also let us run different projects with different (or
conflicting) dependencies on the same server.</p>
</div>
<div class="paragraph">
<p>To reproduce our local virtualenv, we can "save" the list of packages we&#8217;re
using by creating a <em>requirements.txt</em> file. Back on our own machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>echo "django==1.11" &gt; requirements.txt</strong>
$ <strong>git add requirements.txt</strong>
$ <strong>git commit -m "Add requirements.txt for virtualenv"</strong></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may be wondering why we didn&#8217;t add our other dependency,
    Selenium, to our requirements.  The reason is that Selenium is
    only a dependency for the tests, not the application code.  Some
    people like to also create a file called <em>test-requirements.txt</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we do a <code>git push</code> to send our updates up to our code-sharing site:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>$ <strong>git push</strong></pre>
</div>
</div>
<div class="paragraph">
<p>And we can pull those changes down to the server:</p>
</div>
<div class="listingblock server-commands skipme">
<div class="content">
<pre>elspeth@server:$ <strong>git pull</strong>  # may ask you to do some git config first</pre>
</div>
</div>
<div class="paragraph">
<p>We create our virtualenv just like we did on our own machine:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>pwd</strong>
/home/elspeth/sites/superlists-staging.ottg.eu
elspeth@server:$ <strong>python3.6 -m venv virtualenv</strong>
elspeth@server:$ <strong>ls virtualenv/bin</strong>
activate      activate.fish  easy_install-3.6  pip3    python   python3.6
activate.csh  easy_install   pip               pip3.6  python3</pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to activate the virtualenv, we could do so with
<code>source ./virtualenv/bin/activate</code> just like we do locally, but on the
server we don&#8217;t need that. We can actually do everything we want to by directly
calling the versions of Python, pip, and the other executables in the
virtualenv&#8217;s <em>bin</em> directory, as we&#8217;ll soon see.</p>
</div>
<div class="paragraph">
<p>For example, to install our requirements into the virtualenv, we use the
virtualenv pip:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>./virtualenv/bin/pip install -r requirements.txt</strong>
Collecting django==1.11 (from -r requirements.txt (line 1))
[...]
Successfully installed django-1.11 pytz-2017.3</pre>
</div>
</div>
<div class="paragraph">
<p>And to run Python in the virtualenv, we use the virtualenv <code>python</code>
binary:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>./virtualenv/bin/python manage.py runserver</strong>
Performing system checks...

System check identified no issues (0 silenced).
[...]
You have 15 unapplied migration(s). Your project may not work [...]
[...]
Starting development server at http://127.0.0.1:8000/</pre>
</div>
</div>
<div class="paragraph">
<p>If we ignore the ominous message about migrations for now, Django
certainly looks a lot happier.</p>
</div>
<div class="paragraph">
<p>Progress!  We&#8217;ve got a system for getting code to and from the server
(<code>git push</code> and <code>git pull</code>), and we&#8217;ve got a virtualenv set up to match our
local one, and a single file, <em>requirements.txt</em>, to keep them in sync.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_ft_to_check_our_deployment_works">Using the FT to check our deployment works</h4>
<div class="paragraph">
<p>Let&#8217;s see what our FTs think about this version of our site running on
the server. I&#8217;ll use the <code>--failfast</code> option to exit as soon as a single test
fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu ./manage.py test functional_tests --failfast</strong>
[...]
selenium.common.exceptions.WebDriverException: Message: Reached error page: [...]</pre>
</div>
</div>
<div class="paragraph">
<p>Nope!  What&#8217;s going on here?  Time for a little debugging.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_a_deployment_that_doesn_t_seem_to_work_at_all">Debugging a deployment that doesn&#8217;t seem to work at all</h3>
<div class="paragraph">
<p>You may remember that Django&#8217;s runserver usually chooses to run on port 8000.
But a "normal" web server should run on port 80, and that&#8217;s where our FTs are
currently looking, on <em>superlists-staging.ottg.eu</em>.</p>
</div>
<div class="paragraph">
<p>But we can actually use our <code>STAGING_SERVER</code> variable to point the tests at
port 8000. Let&#8217;s try that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu:8000 ./manage.py test functional_tests --failfast</strong>

selenium.common.exceptions.WebDriverException: Message: Reached error page: [...]</pre>
</div>
</div>
<div class="paragraph">
<p>Nope, that didn&#8217;t work earlier.  Let&#8217;s try an even lower-level smoke test, the
traditional Unix utility "curl"&#8201;&#8212;&#8201;it&#8217;s a command-line tool for making web
requests.  Try it on your own computer first:</p>
</div>
<div class="listingblock ignore-errors">
<div class="content">
<pre>$ <strong>curl superlists-staging.ottg.eu</strong>
curl: (7) Failed to connect to superlists-staging.ottg.eu port 80: Connection
refused</pre>
</div>
</div>
<div class="paragraph">
<p>And maybe just to be sure, we could even open up our web browser and type in
<em><a href="http://superlists-staging.ottg.eu:8000" class="bare">http://superlists-staging.ottg.eu:8000</a></em>, and confirm using a familiar tool
that things aren&#8217;t working. Nope.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">On Debugging</div>
<div class="paragraph">
<p>Let me let you in on a little secret.  I&#8217;m actually bad at debugging.  We all
have our psychological strengths and weakness, and one of my weaknesses is that
when I run into a problem I can&#8217;t see an obvious solution to, I tend to throw
up my hands way too soon and say "well, this is hopeless, it can&#8217;t be fixed",
and give up.</p>
</div>
<div class="paragraph">
<p>Thankfully I have some good role models at work who are much better at it than
me (hi Glenn!).   Debugging needs the patience and tenacity of a bloodhound.
If at first you don&#8217;t succeed, you need to systematically rule out options,
check your assumptions, eliminate various aspects of the problem and simplify
things down, find the parts that do and don&#8217;t work, until you eventually find
the cause.</p>
</div>
<div class="paragraph">
<p>It always seems hopeless at first!  But eventually you get there.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re pretty sure the server is running and listening on port 8000, but we
can&#8217;t get to it from the outside.  What about from the inside?  Try
running <code>curl</code> on the server itself:</p>
</div>
<div class="paragraph">
<p>(you&#8217;ll need a second SSH shell onto your server, so as not to interrupt the
existing <code>runserver</code> process):</p>
</div>
<div class="listingblock server-commands small-code">
<div class="content">
<pre>elspeth@server:$ <strong>curl localhost:8000</strong>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;

    [...]
    &lt;title&gt;To-Do lists&lt;/title&gt;
    [...]

  &lt;/body&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Ah-ha!  That looks like the HTML for our site.  So we <em>can</em> reach it from the
server itself, just not from the outside.  What could be going on?</p>
</div>
<div class="paragraph">
<p>Actually there&#8217;s clue in the output that Django prints out:</p>
</div>
<div class="listingblock skipme small-code">
<div class="content">
<pre>Starting development server at http://127.0.0.1:8000/</pre>
</div>
</div>
<div class="paragraph">
<p>Django&#8217;s development server is configured to listen on 127.0.0.1,
aka the "localhost" IP address.  But we&#8217;re trying to reach it from
the outside, via the server&#8217;s "real" public address.</p>
</div>
<div class="paragraph">
<p>But Django isn&#8217;t listening on that address by default.
Here&#8217;s how we tell it to listen on all addresses.  Use Ctrl-C to
interrupt the <code>runserver</code> process, and restart it like this:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>./virtualenv/bin/python manage.py runserver 0.0.0.0:8000</strong>
[...]
Starting development server at http://0.0.0.0:8000/</pre>
</div>
</div>
<div class="paragraph">
<p>And in a second SSH shell, we can confirm it works from the server:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>curl localhost:8000</strong>
&lt;!DOCTYPE html&gt;
[...]
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>What about from our own laptop?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>curl superlists-staging.ottg.eu:8000</strong>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
[...]
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Looks good at first glance!  Let&#8217;s try our FTs again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu:8000 ./manage.py test functional_tests --failfast</strong>

======================================================================
FAIL: test_can_start_a_list_for_one_user
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/functional_tests/tests.py", line 44, in
test_can_start_a_list_for_one_user
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in 'DisallowedHost at /'
 ---------------------------------------------------------------------
Ran 1 test in 4.010s

FAILED (failures=1)
[...]</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point, if your FTs still can&#8217;t talk to the server,
    something else must be in the way.  Check your provider&#8217;s firewall
    settings, and make sure ports 80 and 8000 are open to the world. On AWS,
    for example, you may need to configure the "security group" for your
    server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Oops, spoke too soon!  Another error.  We didn&#8217;t look closely enough at
that <code>curl</code> output&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_allowed_hosts_using_an_environment_variable">Setting ALLOWED_HOSTS using an environment variable</h3>
<div class="paragraph">
<p>Don&#8217;t
be disheartened!  We may have just fixed one problem only to run straight
into another, but this problem is definitely a much easier one.  At least we
can talk to the server!  And it&#8217;s giving us a helpful pointer.  Try opening the
site manually <a href="#django-400-error">Another hitch along the way</a>:</p>
</div>
<div id="django-400-error" class="imageblock">
<div class="content">
<img src="images/django-400-allowed-hosts-page.png" alt="the Django debug page explaining the DisallowedHost error">
</div>
<div class="title">Figure 2. Another hitch along the way</div>
</div>
<div class="paragraph">
<p><code>ALLOWED_HOSTS</code> is a security setting designed to reject requests that are
likely to be forged, broken or malicious because they don&#8217;t appear to be
asking for your site (HTTP request contain the address they were intended for
in a header called "Host").</p>
</div>
<div class="paragraph">
<p>By default, when DEBUG=True, <code>ALLOWED_HOSTS</code> effectively allows <strong>localhost</strong>,
our own machine, so that&#8217;s why it was working OK in dev, and from the server
itself (where we ask for <em>localhost</em>), but not from our own machine (where we
ask for <em>superlists-staging.ottg.eu</em>)</p>
</div>
<div class="paragraph">
<p>There&#8217;s more information in the <a href="http://bit.ly/2u0R2d6">Django docs</a>.</p>
</div>
<div class="paragraph">
<p>The upshot is that we need to adjust <code>ALLOWED_HOSTS</code> in <em>settings.py</em>:</p>
</div>
<div class="exampleblock sourcecode">
<div class="title">superlists/settings.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="comment"># SECURITY WARNING: don't run with debug turned on in production!</span>
DEBUG = <span class="predefined-constant">True</span>

ALLOWED_HOSTS = []
<span class="keyword">if</span> <span class="string"><span class="delimiter">'</span><span class="content">SITENAME</span><span class="delimiter">'</span></span> <span class="keyword">in</span> os.environ:
    ALLOWED_HOSTS = [os.environ[<span class="string"><span class="delimiter">'</span><span class="content">SITENAME</span><span class="delimiter">'</span></span>]]
[...]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Development, staging and live sites always have some differences
    in their configuration. Environment variables are a good place to
    store that configuration.  See
    <a href="http://www.clearlytech.com/2014/01/04/12-factor-apps-plain-english/">the 12-factor app</a><sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We commit that locally, then push it up to github&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "Populate ALLOWED_HOSTS for SITENAME env var."</strong>
$ <strong>git push</strong></pre>
</div>
</div>
<div class="paragraph">
<p>And pull it down on the server, and restart our <code>runserver</code> proces</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>git pull</strong>
elspeth@server:$ <strong>echo $SITENAME</strong> # check this still has our site in
superlists-staging.ottg.eu
elspeth@server:$ <strong>./virtualenv/bin/python manage.py runserver 0.0.0.0:8000</strong></pre>
</div>
</div>
<div class="paragraph">
<p>A quick visual inspection confirms&#8212;&#8203;the site is up (<a href="#staging-is-up">The staging site is up!</a>)!</p>
</div>
<div id="staging-is-up" class="imageblock">
<div class="content">
<img src="images/twp2_0903.png" alt="The front page of the site, at least, is up">
</div>
<div class="title">Figure 3. The staging site is up!</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see what our functional tests say:</p>
</div>
<div class="listingblock small-code">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu:8000 ./manage.py test functional_tests --failfast</strong>
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]</pre>
</div>
</div>
<div class="paragraph">
<p>The tests are failing as soon as they try to submit a new item, because we
haven&#8217;t set up the database. You&#8217;ll probably have spotted the yellow Django
debug page (<a href="#django-debug-screen">But the database isn&#8217;t</a>) telling us as much as the tests went
through, or if you tried it manually.</p>
</div>
<div id="django-debug-screen" class="imageblock">
<div class="content">
<img src="images/twp2_0904.png" alt="Django DEBUG page showing database error">
</div>
<div class="title">Figure 4. But the database isn&#8217;t</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The tests saved us from potential embarrassment there.  The site <em>looked</em>
    fine when we loaded its front page.  If we&#8217;d been a little hasty, we might
    have thought we were done, and it would have been the first users that
    discovered that nasty Django DEBUG page.  Okay, slight exaggeration for
    effect, maybe we <em>would</em> have checked, but what happens as the site gets
    bigger and more complex? You can&#8217;t check everything. The tests can.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_creating_the_database_with_migrate">Creating the Database with migrate</h4>
<div class="paragraph">
<p>We
run <code>migrate</code> using the <code>--noinput</code> argument to suppress the two little "are
you sure" prompts:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>./virtualenv/bin/python manage.py migrate --noinput</strong>
Operations to perform:
  Apply all migrations: auth, contenttypes, lists, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  [...]
  Applying lists.0004_item_list... OK
  Applying sessions.0001_initial... OK</pre>
</div>
</div>
<div class="paragraph">
<p>That looks good.  We restart the server:</p>
</div>
<div class="listingblock server-commands">
<div class="content">
<pre>elspeth@server:$ <strong>./virtualenv/bin/python manage.py runserver 0.0.0.0:8000</strong></pre>
</div>
</div>
<div class="paragraph">
<p>And try the FTs again:</p>
</div>
<div class="listingblock small-code">
<div class="content">
<pre>$ <strong>STAGING_SERVER=superlists-staging.ottg.eu:8000 ./manage.py test functional_tests</strong>
[...]

...
 ---------------------------------------------------------------------
Ran 3 tests in 10.718s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Hooray! Time for a well-earned tea break I think, and perhaps a
<a href="https://en.wikipedia.org/wiki/Digestive_biscuit">Chocolate biscuit</a>.</p>
</div>
</div>
</div>
<div class="sect2 pagebreak-before less_space">
<h3 id="_success_our_hack_deployment_works">Success!  Our Hack Deployment Works</h3>
<div class="paragraph">
<p>Phew.  Assuming you managed to get that up and running, we are at least
reassured that the basic piping works. Notice that the FT was able to guide
us incrementally towards a working site.</p>
</div>
<div class="paragraph">
<p>But we really can&#8217;t be using the Django dev server in production, or running on
port 8000 forever. In the next chapter, we&#8217;ll make our hacky deployment more
production-ready.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Test-Driving Server Configuration and Deployment</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Tests take some of the uncertainty out of deployment</dt>
<dd>
<p>For
developers, server administration is always "fun", by which I mean, a
process full of uncertainty and surprises. My aim during this chapter was
to show that a functional test suite can take some of the uncertainty out
of the process.</p>
</dd>
<dt class="hdlist1">Some typical pain points&#8212;&#8203;networking, ports, static files, and the database</dt>
<dd>
<p>The things that you need to keep an eye out for on any deployment include
making sure your database configuration, static files, software
dependencies, and custom settings that differ between development and
production.  You&#8217;ll need to think through each of these for your own
deployments.</p>
</dd>
<dt class="hdlist1">Tests allow us to experiment</dt>
<dd>
<p>Whenever we make a change to our server configuration, we can rerun the
test suite, and be confident that everything works as well as it did
before.  It allows us to experiment with our setup with less fear (as
we&#8217;ll see in the next chapter).</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. What I&#8217;m calling a "staging" server, some people would call a "development" server, and some others would also like to distinguish "preproduction" servers.  Whatever we call it, the point is to have somewhere we can try our code out in an environment that&#8217;s as similar as possible to the real production server.
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. Another common way of handling this is to have different versions of     <em>settings.py</em> for dev and prod.  That can work fine too, but it can     get confusing to manage.  Environment variables also have the advantage     of working for non-django stuff too&#8230;&#8203;
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-01-07 20:09:39 GMT
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = 'chapter_manual_deployment';
    };
    
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//obeythetestinggoat.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>