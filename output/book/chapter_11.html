<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Input Validation and Test Organisation</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script>var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() {
  if (httpRequest.readyState === XMLHttpRequest.DONE) {
    if (httpRequest.status === 200) {
      document.getElementById('header').innerHTML += httpRequest.responseText;
    }
  }
};
httpRequest.open('GET', 'toc.html');
httpRequest.send();

</script></head>
<body class="article toc2 toc-left">
<div id="buy_the_book" style="position: absolute; top: 0; right: 0; z-index:100">
  <a href="/pages/book.html">
    <img src="images/buy_the_book.svg" alt="buy the book ribbon">
  </a>
</div>
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="manual-validation-chapter">Input Validation and Test Organisation</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Major update released for Selenium 3.
    If you started this book on or before Jan 30th 2017,
    be aware: chapters have been renumbered,
    so check this is the one you think it is,
    and have a look at the new <a href="/book/chapter_06.html">[explicit-waits-chapter]</a>
    for an indication of the changes you&#8217;ll need in your FTs.
    You should do a <code>pip install --upgrade selenium</code> too.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Over the next few chapters we&#8217;ll talk about testing and implementing validation
of user inputs. We&#8217;ll also take the opportunity to do a little tidying up&#8212;&#8203;both
in our application code, and also in our tests.</p>
</div>
<div class="paragraph">
<p>In terms of content, there&#8217;s going to be quite a lot of material here that&#8217;s
more about the specifics of Django, and less discussion of TDD philosophy. That
doesn&#8217;t mean you won&#8217;t be learning anything about testing&#8212;&#8203;there are plenty of
little testing tidbits in here, but perhaps it&#8217;s more about really getting into
the swing of things, the rhythm of TDD and how we get work done.</p>
</div>
<div class="paragraph">
<p>Once we get through these three chapters, I&#8217;ve saved a bit of fun with
JavaScript for the end of Part 2. Then it&#8217;s on to <a href="/book/part3.harry.html">Part 3</a>, where I
promise we&#8217;ll get right back into some of the real core discussions in
TDD methodology&#8212;&#8203;unit tests vs integrated tests, mocking and more.  Stay tuned!</p>
</div>
<div class="paragraph">
<p>But for now, a little validation.</p>
</div>
<div class="sect2">
<h3 id="_validation_ft_preventing_blank_items">Validation FT: Preventing Blank Items</h3>
<div class="paragraph">
<p>
As our first few users start using the site, we&#8217;ve noticed they sometimes make
mistakes that mess up their lists, like accidentally submitting blank list
items, or accidentally inputting two identical items to a list.  Computers are
meant to help stop us from making silly mistakes, so let&#8217;s see if we can get
our site to help.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the outline of an FT:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/tests.py (ch11l001)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):
    <span class="comment"># Edith goes to the home page and accidentally tries to submit</span>
    <span class="comment"># an empty list item. She hits Enter on the empty input box</span>

    <span class="comment"># The home page refreshes, and there is an error message saying</span>
    <span class="comment"># that list items cannot be blank</span>

    <span class="comment"># She tries again with some text for the item, which now works</span>

    <span class="comment"># Perversely, she now decides to submit a second blank list item</span>

    <span class="comment"># She receives a similar warning on the list page</span>

    <span class="comment"># And she can correct it by filling some text in</span>
    <span class="predefined-constant">self</span>.fail(<span class="string"><span class="delimiter">'</span><span class="content">write me!</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s all very well, but before we go any further&#8212;&#8203;our functional tests
file is beginning to get a little crowded.  Let&#8217;s split it out into several
files, in which each has a single test method.</p>
</div>
<div class="paragraph">
<p>
Remember that functional tests are closely linked to "user stories". If you
were using some sort of project management tool like an issue tracker, you
might make it so that each file matched one issue or ticket, and its filename
contained the ticket ID.  Or, if you prefer to think about things in terms of
"features", where one feature may have several user stories, then you might
have one file and class for the feature, and several methods for each of its
user stories.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll also have one base test class which they can all inherit from.  Here&#8217;s
how to get there step by step.</p>
</div>
<div class="sect3">
<h4 id="_skipping_a_test">Skipping a Test</h4>
<div class="paragraph">
<p>

It&#8217;s always nice, when doing refactoring, to have a fully passing test suite.
We&#8217;ve just written a test with a deliberate failure. Let&#8217;s temporarily switch
it off, using a decorator called "skip" from <code>unittest</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/tests.py (ch11l001-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">unittest</span> <span class="keyword">import</span> <span class="include">skip</span>
[...]

    <span class="decorator">@skip</span>
    <span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):</code></pre>
</div>
</div>
<div class="paragraph">
<p>This tells the test runner to ignore this test.  You can see it works&#8212;&#8203;if we
rerun the tests, it&#8217;ll say it passes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
Ran 4 tests in 11.577s
OK</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Skips are dangerous&#8212;&#8203;you need to remember to remove them before you
    commit your changes back to the repo.  This is why line-by-line reviews of
    each of your diffs are a good idea!
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Don&#8217;t Forget the "Refactor" in "Red, Green, Refactor"</div>
<div class="paragraph">
<p>

A criticism that&#8217;s sometimes levelled at TDD is that it leads to badly
architected code, as the developer just focuses on getting tests to pass
rather than stopping to think about how the whole system should be designed.
I think it&#8217;s slightly unfair.</p>
</div>
<div class="paragraph">
<p><em>TDD is no silver bullet</em>. You still have to spend time thinking about good
design.  But what often happens is that people forget the "Refactor" in "Red,
Green, Refactor". The methodology allows you to throw together any old code to
get your tests to pass, but it <em>also</em> asks you to then spend some time
refactoring it to improve its design.</p>
</div>
<div class="paragraph">
<p>Often, however, the best ideas for how to refactor code don&#8217;t occur to you
straight away. They may occur to you days, weeks, even months after you
wrote a piece of code, when you&#8217;re working on something totally unrelated
and you happen to see some old code again with fresh eyes. But if you&#8217;re
halfway through something else, should you stop to refactor the old code?</p>
</div>
<div class="paragraph">
<p>The answer is that it depends.  In the case at the beginning of the chapter,
we haven&#8217;t even started writing our new code. We know we are in a working
state, so we can justify putting a skip on our new FT (to get back to fully
passing tests) and do a bit of refactoring straight away.</p>
</div>
<div class="paragraph">
<p>Later in the chapter we&#8217;ll spot other bits of code we want to alter.
In those cases, rather than taking the risk of refactoring an application
that&#8217;s not in a working state, we&#8217;ll make a note of the thing we want to
change on our scratchpad and wait until we&#8217;re back to a fully passing test
suite before refactoring.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_splitting_functional_tests_out_into_many_files">Splitting Functional Tests out into Many Files</h4>
<div class="paragraph">
<p>
We start putting each test into its own class, still in the same file:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/tests.py (ch11l002)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">FunctionalTest</span>(StaticLiveServerTestCase):

    <span class="decorator">@classmethod</span>
    <span class="keyword">def</span> <span class="function">setUpClass</span>(cls):
        [...]
    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">tearDown</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">wait_for_row_in_list_table</span>(<span class="predefined-constant">self</span>, row_text):
        [...]


<span class="keyword">class</span> <span class="class">NewVisitorTest</span>(FunctionalTest):

    <span class="keyword">def</span> <span class="function">test_can_start_a_list_for_one_user</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">test_multiple_users_can_start_lists_at_different_urls</span>(<span class="predefined-constant">self</span>):
        [...]


<span class="keyword">class</span> <span class="class">LayoutAndStylingTest</span>(FunctionalTest):

    <span class="keyword">def</span> <span class="function">test_layout_and_styling</span>(<span class="predefined-constant">self</span>):
        [...]



<span class="keyword">class</span> <span class="class">ItemValidationTest</span>(FunctionalTest):

    <span class="decorator">@skip</span>
    <span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point we can rerun the FTs and see they all still work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 4 tests in 11.577s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s labouring it a little bit, and we could probably get away doing this
stuff in fewer steps, but, as I keep saying, practising the step-by-step method
on the easy cases makes it that much easier when we have a complex case.</p>
</div>
<div class="paragraph">
<p>Now we switch from a single tests file to using one for each class, and one
"base" file to contain the base class all the tests will inherit from.  We&#8217;ll
make four copies of <em>tests.py</em>, naming them appropriately, and then delete the
parts we don&#8217;t need from each:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git mv functional_tests/tests.py functional_tests/base.py</strong>
$ <strong>cp functional_tests/base.py functional_tests/test_simple_list_creation.py</strong>
$ <strong>cp functional_tests/base.py functional_tests/test_layout_and_styling.py</strong>
$ <strong>cp functional_tests/base.py functional_tests/test_list_item_validation.py</strong></pre>
</div>
</div>
<div class="paragraph">
<p>
<em>base.py</em> can be cut down to just the <code>FunctionalTest</code> class.  We leave the
helper method on the base class, because we suspect we&#8217;re about to reuse
it in our new FT:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/base.py (ch11l003)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.contrib.staticfiles.testing</span> <span class="keyword">import</span> <span class="include">StaticLiveServerTestCase</span>
<span class="keyword">from</span> <span class="include">selenium</span> <span class="keyword">import</span> <span class="include">webdriver</span>
<span class="keyword">import</span> <span class="include">sys</span>

<span class="keyword">class</span> <span class="class">FunctionalTest</span>(StaticLiveServerTestCase):

    <span class="decorator">@classmethod</span>
    <span class="keyword">def</span> <span class="function">setUpClass</span>(cls):
        [...]
    <span class="keyword">def</span> <span class="function">setUp</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">tearDown</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">wait_for_row_in_list_table</span>(<span class="predefined-constant">self</span>, row_text):
        [...]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Keeping helper methods in a base <code>FunctionalTest</code> class is one useful way
    of preventing duplication in FTs.  Later in the book (in
    <a href="/book/chapter_22.html">[page-pattern-chapter]</a>) we&#8217;ll use the "Page pattern", which is related,
    but prefers composition over inheritance, always a good thing.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Our first FT is now in its own file, and should be just one class and one test
method:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_simple_list_creation.py (ch11l004)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> .base <span class="keyword">import</span> <span class="include">FunctionalTest</span>
<span class="keyword">from</span> <span class="include">selenium</span> <span class="keyword">import</span> <span class="include">webdriver</span>
<span class="keyword">from</span> <span class="include">selenium.webdriver.common.keys</span> <span class="keyword">import</span> <span class="include">Keys</span>


<span class="keyword">class</span> <span class="class">NewVisitorTest</span>(FunctionalTest):

    <span class="keyword">def</span> <span class="function">test_can_start_a_list_for_one_user</span>(<span class="predefined-constant">self</span>):
        [...]
    <span class="keyword">def</span> <span class="function">test_multiple_users_can_start_lists_at_different_urls</span>(<span class="predefined-constant">self</span>):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>
I used a relative import (<code>from .base</code>). Some people like to use them a lot
in Django code (e.g., your views might import models using <code>from .models import
List</code>, instead of <code>from list.models</code>). Ultimately this is a
matter of personal preference.  I prefer to use relative imports only when I&#8217;m
super-super sure that the relative position of the thing I&#8217;m importing won&#8217;t
change.  That applies in this case because I know for sure all the tests will
sit next to <em>base.py</em>, which they inherit from.</p>
</div>
<div class="paragraph">
<p>

The layout and styling FT should now be one file and one class:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_layout_and_styling.py (ch11l005)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">selenium.webdriver.common.keys</span> <span class="keyword">import</span> <span class="include">Keys</span>
<span class="keyword">from</span> .base <span class="keyword">import</span> <span class="include">FunctionalTest</span>


<span class="keyword">class</span> <span class="class">LayoutAndStylingTest</span>(FunctionalTest):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lastly our new validation test is in a file of its own too:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_list_item_validation.py (ch11l006)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">selenium.webdriver.common.keys</span> <span class="keyword">import</span> <span class="include">Keys</span>
<span class="keyword">from</span> <span class="include">unittest</span> <span class="keyword">import</span> <span class="include">skip</span>
<span class="keyword">from</span> .base <span class="keyword">import</span> <span class="include">FunctionalTest</span>


<span class="keyword">class</span> <span class="class">ItemValidationTest</span>(FunctionalTest):

    <span class="decorator">@skip</span>
    <span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we can test everything worked by rerunning <code>manage.py test
functional_tests</code>, and checking once again that all four tests are run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 4 tests in 11.577s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Now we can remove our skip:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_list_item_validation.py (ch11l007)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ItemValidationTest</span>(FunctionalTest):

    <span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):
        [...]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_a_single_test_file">Running a Single Test File</h4>
<div class="paragraph">
<p>As a side bonus, we&#8217;re now able to run an individual test file, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_list_item_validation</strong>
[...]
AssertionError: write me!</pre>
</div>
</div>
<div class="paragraph">
<p>Brilliant, no need to sit around waiting for all the FTs when we&#8217;re only
interested in a single one. Although we need to remember to run all of them
now and again, to check for regressions.  Later in the book we&#8217;ll see how
to give that task over to an automated Continuous Integration loop. For now
let&#8217;s commit!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git status</strong>
$ <strong>git add functional_tests</strong>
$ <strong>git commit -m "Moved Fts into their own individual files"</strong></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_new_functional_test_tool_a_generic_explicit_wait_helper">A new functional test tool: a generic explicit wait helper</h3>
<div class="paragraph">
<p>Now let&#8217;s start implementing the test, or at least the beginning of it:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_list_item_validation.py (ch11l008)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">test_cannot_add_empty_list_items</span>(<span class="predefined-constant">self</span>):
    <span class="comment"># Edith goes to the home page and accidentally tries to submit</span>
    <span class="comment"># an empty list item. She hits Enter on the empty input box</span>
    <span class="predefined-constant">self</span>.browser.get(<span class="predefined-constant">self</span>.server_url)
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(Keys.ENTER)

    <span class="comment"># The home page refreshes, and there is an error message saying</span>
    <span class="comment"># that list items cannot be blank</span>
    <span class="predefined-constant">self</span>.assertEqual(
        <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.has-error</span><span class="delimiter">'</span></span>).text,  <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>  <i class="conum" data-value="2"></i><b>(2)</b>
    )

    <span class="comment"># She tries again with some text for the item, which now works</span>
    <span class="predefined-constant">self</span>.fail(<span class="string"><span class="delimiter">'</span><span class="content">finish this test!</span><span class="delimiter">'</span></span>)
    [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is how we might write the test naively:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We specify we&#8217;re going to use a CSS class called <code>.has-error</code> to mark our
error text.  We&#8217;ll see that Bootstrap has some useful styling for those</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>And we can check that our error displays the message we want.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>But can you guess what the potential problem is with the test as it&#8217;s written
now?</p>
</div>
<div class="paragraph">
<p>OK, I gave it away in the section header, but whenever we do something
that causes a page refresh, we need an explicit wait, otherwise Selenium
might go looking for the <code>.has-error</code> element before the page has had a
chance to load.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Whenever you submit a form with <code>Keys.ENTER</code> or click something that
    is going to cause a page to load, you probably want an explicit wait
    for your next assertion.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Our first explicit wait was built into a helper method.  For this one, we
might decide that building a helper method is overkill at this stage, but
it might be nice to have some way of saying, in our tests, "wait until this
assertion passes".  Something like this:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_list_item_validation.py (ch11l009)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">[...]
    <span class="comment"># The home page refreshes, and there is an error message saying</span>
    <span class="comment"># that list items cannot be blank</span>
    <span class="predefined-constant">self</span>.wait_for(<span class="keyword">lambda</span>: <span class="predefined-constant">self</span>.assertEqual(  <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.has-error</span><span class="delimiter">'</span></span>).text,
        <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
    ))</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Rather than calling the assertion directly, we wrap it in a lambda
function, and we pass it to a new helper method we imagine called
<code>wait_for</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you&#8217;ve never seen lambda functions in Python before, see the sidebar
    below.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So how would this magical <code>wait_for</code> method work?  Let&#8217;s head over to
<em>base.py</em>, and make a copy of our existing <code>wait_for_row_in_list_table</code> method,
and we&#8217;ll adapt it slightly:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/base.py (ch11l010)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">wait_for</span>(<span class="predefined-constant">self</span>, fn):  <i class="conum" data-value="1"></i><b>(1)</b>
        start_time = time.time()
        <span class="keyword">while</span> <span class="predefined-constant">True</span>:
            <span class="keyword">try</span>:
                table = <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_list_table</span><span class="delimiter">'</span></span>)  <i class="conum" data-value="2"></i><b>(2)</b>
                rows = table.find_elements_by_tag_name(<span class="string"><span class="delimiter">'</span><span class="content">tr</span><span class="delimiter">'</span></span>)
                <span class="predefined-constant">self</span>.assertIn(row_text, [row.text <span class="keyword">for</span> row <span class="keyword">in</span> rows])
                <span class="keyword">return</span>
            <span class="keyword">except</span> (<span class="exception">AssertionError</span>, WebDriverException) <span class="keyword">as</span> e:
                <span class="keyword">if</span> time.time() - start_time &gt; MAX_WAIT:
                    <span class="keyword">raise</span> e
                time.sleep(<span class="float">0.5</span>)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We make a copy of the method, but we name it <code>wait_for</code>, and we change its
argument.  It is expecting to be passed a function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For now we&#8217;ve still got the old code that&#8217;s checking table rows.  How to
transform this into something that works for any generic <code>fn</code> that&#8217;s been
passed in?</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like this:</p>
</div>
<div id="self.wait-for" class="listingblock sourcecode">
<div class="title">functional_tests/base.py (ch11l011)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">wait_for</span>(<span class="predefined-constant">self</span>, fn):
        start_time = time.time()
        <span class="keyword">while</span> <span class="predefined-constant">True</span>:
            <span class="keyword">try</span>:
                <span class="keyword">return</span> fn()  <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="keyword">except</span> (<span class="exception">AssertionError</span>, WebDriverException) <span class="keyword">as</span> e:
                <span class="keyword">if</span> time.time() - start_time &gt; MAX_WAIT:
                    <span class="keyword">raise</span> e
                time.sleep(<span class="float">0.5</span>)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The body of our try/except, instead of being the specific code for
examining table rows, just becomes a call to the function we passed
in.  We also <code>return</code> its return value to be able to exit the loop
immediately if no exception is raised.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">lambda functions</div>
<div class="paragraph">
<p><code>lambda</code> in Python is the syntax for making a one-line, throwaway function&#8212;&#8203;it
saves you from having to use <code>def..():</code> and an indented block.</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">&gt;&gt;&gt; myfn = <span class="keyword">lambda</span> x: x+<span class="integer">1</span>
&gt;&gt;&gt; myfn(<span class="integer">2</span>)
<span class="integer">3</span>
&gt;&gt;&gt; myfn(<span class="integer">5</span>)
<span class="integer">6</span>
&gt;&gt;&gt; adder = <span class="keyword">lambda</span> x, y: x + y
&gt;&gt;&gt; adder(<span class="integer">3</span>, <span class="integer">2</span>)
<span class="integer">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In our case, we&#8217;re using it to transform a bit of code that would otherwise be
executed immediately into a function that we can pass as an argument, and that
can be executed later, and multiple times:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">&gt;&gt;&gt; <span class="keyword">def</span> <span class="function">addthree</span>(x):
...     <span class="keyword">return</span> x + <span class="integer">3</span>
...
&gt;&gt;&gt; addthree(<span class="integer">2</span>)
<span class="integer">5</span>
&gt;&gt;&gt; myfn = <span class="keyword">lambda</span>: addthree(<span class="integer">2</span>)  <span class="comment"># note addthree is not called immediately here</span>
&gt;&gt;&gt; myfn
&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="hex">0x7f3b140339d8</span>&gt;
&gt;&gt;&gt; myfn()
<span class="integer">5</span>
&gt;&gt;&gt; myfn()
<span class="integer">5</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see our funky <code>wait_for</code> helper in action:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_list_item_validation</strong>
Creating test database for alias 'default'...
E
======================================================================
ERROR: test_cannot_add_empty_list_items
(functional_tests.test_list_item_validation.ItemValidationTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/test_list_item_validation.py", line
15, in test_cannot_add_empty_list_items
    self.wait_for(lambda: self.assertEqual(  <i class="conum" data-value="1"></i><b>(1)</b>
  File "/.../superlists/functional_tests/base.py", line 37, in wait_for
    raise e  <i class="conum" data-value="2"></i><b>(2)</b>
  File "/.../superlists/functional_tests/base.py", line 34, in wait_for
    return fn()  <i class="conum" data-value="2"></i><b>(2)</b>
  File "/.../superlists/functional_tests/test_list_item_validation.py", line
16, in &lt;lambda&gt;  <i class="conum" data-value="3"></i><b>(3)</b>
    self.browser.find_element_by_css_selector('.has-error').text,  <i class="conum" data-value="3"></i><b>(3)</b>
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .has-error


 ---------------------------------------------------------------------
Ran 1 test in 10.575s

FAILED (errors=1)</pre>
</div>
</div>
<div class="paragraph">
<p>The order of the traceback is a little confusing, but we can more or less follow
through what happened:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>At line 15 in our FT, we go into our <code>self.wait_for</code> helper, passing it the
<code>lambda</code>-ified version of the <code>assertEqual</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We go into <code>self.wait_for</code> in <em>base.py</em>, where we can see that we&#8217;ve called
the lambda, enough times that we&#8217;ve dropped out to the <code>raise e</code> because
our timeout expired</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To explain where the exception has actually come from, the traceback takes us
back into <em>test_list_item_validation.py</em> and inside the body of the <code>lambda</code>
function, and tells us that it was trying to find the <code>.has-error</code> element
that failed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We&#8217;re into the realm of functional programming now, passing functions as
arguments to other functions, and it can be a little mind-bending.  I know
it took me a little while to get used to!  Have a couple of read-throughs
of this code, and the code back in the FT, to let it sink in;  and if you&#8217;re
still confused, don&#8217;t worry about it too much, and let your confidence grow
from working with it.  We&#8217;ll use it a few more times in this book, and make it
even more functionally fun, you&#8217;ll see.</p>
</div>
</div>
<div class="sect2">
<h3 id="_finishing_off_the_ft">Finishing off the FT</h3>
<div class="paragraph">
<p>We&#8217;ll finish off the FT like this:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">functional_tests/test_list_item_validation.py (ch11l012)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="comment"># The home page refreshes, and there is an error message saying</span>
    <span class="comment"># that list items cannot be blank</span>
    <span class="predefined-constant">self</span>.wait_for(<span class="keyword">lambda</span>: <span class="predefined-constant">self</span>.assertEqual(
        <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.has-error</span><span class="delimiter">'</span></span>).text,
        <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
    ))

    <span class="comment"># She tries again with some text for the item, which now works</span>
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(<span class="string"><span class="delimiter">'</span><span class="content">Buy milk</span><span class="delimiter">'</span></span>)
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(Keys.ENTER)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">1: Buy milk</span><span class="delimiter">'</span></span>)

    <span class="comment"># Perversely, she now decides to submit a second blank list item</span>
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(Keys.ENTER)

    <span class="comment"># She receives a similar warning on the list page</span>
    <span class="predefined-constant">self</span>.wait_for(<span class="keyword">lambda</span>: <span class="predefined-constant">self</span>.assertEqual(
        <span class="predefined-constant">self</span>.browser.find_element_by_css_selector(<span class="string"><span class="delimiter">'</span><span class="content">.has-error</span><span class="delimiter">'</span></span>).text,
        <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
    ))

    <span class="comment"># And she can correct it by filling some text in</span>
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(<span class="string"><span class="delimiter">'</span><span class="content">Make tea</span><span class="delimiter">'</span></span>)
    <span class="predefined-constant">self</span>.browser.find_element_by_id(<span class="string"><span class="delimiter">'</span><span class="content">id_new_item</span><span class="delimiter">'</span></span>).send_keys(Keys.ENTER)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">1: Buy milk</span><span class="delimiter">'</span></span>)
    <span class="predefined-constant">self</span>.wait_for_row_in_list_table(<span class="string"><span class="delimiter">'</span><span class="content">2: Make tea</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>
.Helper methods in FTs</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>We&#8217;ve got two helper methods now, our generic <code>self.wait_for</code> helper, and
<code>wait_for_row_in_list_table</code>.  The former is a general utility&#8201;&#8212;&#8201;any of our
FTs might need to do a wait.  The second also helps prevent duplication across
your functional test code.  The day we decide to change the implementation of
how our list table works, we want to make sure we only have to change our FT
code in one place, not in dozens of places across loads of FTs&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="paragraph">
<p>And we&#8217;re off! I&#8217;ll let you do your own "first-cut FT" commit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_model_layer_validation">Using Model-Layer Validation</h3>
<div class="paragraph">
<p>


There are two levels at which you can do validation in Django. One is
at the model level, and the other is higher up at the forms level.  I
like to use the lower level whenever possible, partially because I&#8217;m
a bit too fond of databases and database integrity rules, and partially
because it&#8217;s safer&#8212;&#8203;you can sometimes forget which form you use to
validate input, but you&#8217;re always going to use the same database.</p>
</div>
<div class="sect3">
<h4 id="_refactoring_unit_tests_into_several_files">Refactoring Unit Tests into Several Files</h4>
<div class="paragraph">
<p>


We&#8217;re going to want to add another test for our model, but before we
do so, it&#8217;s time to tidy up our unit tests in a similar way to the
functional tests.  A difference will be that, because the <code>lists</code>
app contains real application code as well as tests, we&#8217;ll separate
out the tests into their own folder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>mkdir lists/tests</strong>
$ <strong>touch lists/tests/__init__.py</strong>
$ <strong>git mv lists/tests.py lists/tests/test_all.py</strong>
$ <strong>git status</strong>
$ <strong>git add lists/tests</strong>
$ <strong>python manage.py test lists</strong>
[...]
Ran 9 tests in 0.034s

OK
$ <strong>git commit -m "Move unit tests into a folder with single file"</strong></pre>
</div>
</div>
<div class="paragraph">
<p>If you get a message saying "Ran 0 tests", you probably forgot to add the
dunderinit&#8212;&#8203;it needs to be there or else the tests folder isn&#8217;t a valid Python
package&#8230;&#8203;<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>Now we turn <em>test_all.py</em> into two files, one called <em>test_views.py</em>, which
only contains view tests, and one called <em>test_models.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git mv lists/tests/test_all.py lists/tests/test_views.py</strong>
$ <strong>cp lists/tests/test_views.py lists/tests/test_models.py</strong></pre>
</div>
</div>
<div class="paragraph">
<p>We strip <em>test_models.py</em> down to being just the one test&#8212;&#8203;it means
it needs far fewer imports:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_models.py (ch11l016)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.test</span> <span class="keyword">import</span> <span class="include">TestCase</span>
<span class="keyword">from</span> <span class="include">lists.models</span> <span class="keyword">import</span> <span class="include">Item</span>, <span class="include">List</span>


<span class="keyword">class</span> <span class="class">ListAndItemModelsTest</span>(TestCase):
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whereas <em>test_views.py</em>  just loses one class:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l017)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="diff"><span class="line head"><span class="head">--- </span><span class="filename">a/lists/tests/test_views.py</span></span>
<span class="line head"><span class="head">+++ </span><span class="filename">b/lists/tests/test_views.py</span></span>
<span class="change"><span class="change">@@</span> -103,34 +104,3 <span class="change">@@</span></span> <span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):
         <span class="predefined-constant">self</span>.assertNotContains(response, <span class="string"><span class="delimiter">'</span><span class="content">other list item 1</span><span class="delimiter">'</span></span>)
         <span class="predefined-constant">self</span>.assertNotContains(response, <span class="string"><span class="delimiter">'</span><span class="content">other list item 2</span><span class="delimiter">'</span></span>)

<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span><span class="keyword">class</span> <span class="class">ListAndItemModelsTest</span>(TestCase):</span>
<span class="line delete"><span class="delete">-</span></span>
<span class="line delete"><span class="delete">-</span>    <span class="keyword">def</span> <span class="function">test_saving_and_retrieving_items</span>(<span class="predefined-constant">self</span>):</span>
<span class="line comment">[...]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We rerun the tests to check everything is still there:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
[...]
Ran 9 tests in 0.040s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Great!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git add lists/tests</strong>
$ <strong>git commit -m "Split out unit tests into two files"</strong></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some people like to make their unit tests into a tests folder straight
    away, as soon as they start a project. That&#8217;s a perfectly good idea; I just
    thought I&#8217;d wait until it became necessary, to avoid doing too much
    housekeeping all in the first chapter!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TODO: separate this out into two chapters, at this point maybe?</p>
</div>
</div>
<div class="sect3">
<h4 id="_unit_testing_model_validation_and_the_self_assertraises_context_manager">Unit Testing Model Validation and the self.assertRaises Context Manager</h4>
<div class="paragraph">
<p>


Let&#8217;s add a new test method to <code>ListAndItemModelsTest</code>, which tries to create
a blank list item:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_models.py (ch11l018)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.core.exceptions</span> <span class="keyword">import</span> <span class="include">ValidationError</span>
[...]

<span class="keyword">class</span> <span class="class">ListAndItemModelsTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_cannot_save_empty_list_items</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        item = Item(list=list_, text=<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)
        <span class="keyword">with</span> <span class="predefined-constant">self</span>.assertRaises(ValidationError):
            item.save()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you&#8217;re new to Python, you may never have seen the <code>with</code> statement.
    It&#8217;s used with what are called "context managers", which wrap a block of
    code, usually with some kind of setup, cleanup, or error-handling code.
    There&#8217;s a good write-up in the
    <a href="http://docs.python.org/release/2.5/whatsnew/pep-343.html">Python 2.5 release notes</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is a new unit testing technique: when we want to check that doing
something will raise an error, we can use the <code>self.assertRaises</code> context
manager.  We could have used something like this instead:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">try</span>:
    item.save()
    <span class="predefined-constant">self</span>.fail(<span class="string"><span class="delimiter">'</span><span class="content">The save should have raised an exception</span><span class="delimiter">'</span></span>)
<span class="keyword">except</span> ValidationError:
    <span class="keyword">pass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But the <code>with</code> formulation is neater.  Now, we can try running the test,
and see its expected failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    item.save()
AssertionError: ValidationError not raised</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_django_quirk_model_save_doesn_t_run_validation">A Django Quirk: Model Save Doesn&#8217;t Run Validation</h4>
<div class="paragraph">
<p>
And now we discover one of Django&#8217;s little quirks. <em>This test should already
pass</em>.  If you take a look at the
<a href="http://bit.ly/SuxPJO">docs for the Django model fields</a>,
you&#8217;ll see that <code>TextField</code> actually defaults to <code>blank=False</code>, which means
that it <em>should</em> disallow empty values.</p>
</div>
<div class="paragraph">
<p>So why is the test not failing?  Well, for
<a href="https://groups.google.com/forum/#!topic/django-developers/uIhzSwWHj4c">slightly
counterintuitive historical reasons</a>, Django models don&#8217;t run full validation
on save.  As we&#8217;ll see later, any constraints that are actually implemented in
the database will raise errors on save, but SQLite doesn&#8217;t support enforcing
emptiness constraints on text columns, and so our save method is letting this
invalid value through silently.</p>
</div>
<div class="paragraph">
<p>There&#8217;s a way of checking whether the constraint will happen at the database
level or not:  if it was at the database level, we would need a migration to
apply the constraint. But, Django knows that SQLite doesn&#8217;t support this type
of constraint, so if we try and run <code>makemigrations</code>, it will report there&#8217;s
nothing to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py makemigrations</strong>
No changes detected</pre>
</div>
</div>
<div class="paragraph">
<p>Django does have a method to manually run full validation however, called
<code>full_clean</code>.  Let&#8217;s hack it in to see it work:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_models.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">with</span> <span class="predefined-constant">self</span>.assertRaises(ValidationError):
        item.save()
        item.full_clean()</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gets the test to pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
<div class="paragraph">
<p>That taught us a little about Django validation, and the test is there to
warn us if we ever forget our requirement and set <code>blank=True</code> on the <code>text</code>
field (try it!).
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_surfacing_model_validation_errors_in_the_view">Surfacing Model Validation Errors in the View</h3>
<div class="paragraph">
<p>

Let&#8217;s try and enforce our model validation in the views layer and bring it up
through into our templates, so the user can see them. Here&#8217;s how we can
optionally display an error in our HTML&#8212;&#8203;we check whether the template has
been passed an error variable, and if so, we display it next to the form:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/base.html (ch11l020)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html"><span class="tag">&lt;form</span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">"</span><span class="content">POST</span><span class="delimiter">"</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">"</span><span class="content">{% block form_action %}{% endblock %}</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;input</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">"</span><span class="content">item_text</span><span class="delimiter">"</span></span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">id_new_item</span><span class="delimiter">"</span></span>
           <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">form-control input-lg</span><span class="delimiter">"</span></span>
           <span class="attribute-name">placeholder</span>=<span class="string"><span class="delimiter">"</span><span class="content">Enter a to-do item</span><span class="delimiter">"</span></span>
    <span class="tag">/&gt;</span>
    {% csrf_token %}
    {% if error %}
        <span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">form-group has-error</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;span</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">help-block</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>{{ error }}<span class="tag">&lt;/span&gt;</span>
        <span class="tag">&lt;/div&gt;</span>
    {% endif %}
<span class="tag">&lt;/form&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Take a look at the <a href="http://getbootstrap.com/css/#forms">Bootstrap docs</a> for more
info on form controls.</p>
</div>
<div class="paragraph">
<p>Passing this error to the template is the job of the view function. Let&#8217;s take
a look at the unit tests in the <code>NewListTest</code> class.  I&#8217;m going to use two
slightly different error-handling patterns here.</p>
</div>
<div class="paragraph">
<p>In the first case, our URL and view for new lists will optionally render the
same template as the home page, but with the addition of an error message.
Here&#8217;s a unit test for that:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l021)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_validation_errors_are_sent_back_to_home_page_template</span>(<span class="predefined-constant">self</span>):
        response = <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(response.status_code, <span class="integer">200</span>)
        <span class="predefined-constant">self</span>.assertTemplateUsed(response, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>)
        expected_error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
        <span class="predefined-constant">self</span>.assertContains(response, expected_error)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we&#8217;re writing this test, we might get slightly offended by the <em>/lists/new</em>
URL, which we&#8217;re manually entering as a string. We&#8217;ve got a lot of URLs
hardcoded in our tests, in our views, and in our templates, which violates the
DRY principle.  I don&#8217;t mind a bit of duplication in tests, but we should
definitely be on the lookout for hardcoded URLs in our views and templates,
and make a note to refactor them out.  But we won&#8217;t do them straight away,
because right now our application is in a broken state. We want to get back
to a working state first.</p>
</div>
<div class="paragraph">
<p>Back to our test, which is failing because the view is currently returning a
302 redirect, rather than a "normal" 200 response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: 302 != 200</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try calling <code>full_clean()</code> in the view:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    list_ = List.objects.create()
    item = Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    item.full_clean()
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we&#8217;re looking at the view code, we find a good candidate for a hardcoded
URL to get rid of.  Let&#8217;s add that to our scratchpad:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Remove hardcoded URLs from views.py</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Now the model validation raises an exception, which comes up through our view:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[...]
  File "/.../superlists/lists/views.py", line 11, in new_list
    item.full_clean()
[...]
django.core.exceptions.ValidationError: {'text': ['This field cannot be
blank.']}</pre>
</div>
</div>
<div class="paragraph">
<p>So we try our first approach:  using a <code>try/except</code> to detect errors. Obeying
the Testing Goat, we start with just the <code>try/except</code> and nothing else.  The
tests should tell us what to code next&#8230;&#8203;</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l025)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.core.exceptions</span> <span class="keyword">import</span> <span class="include">ValidationError</span>
[...]

<span class="keyword">def</span> <span class="function">new_list</span>(request):
    list_ = List.objects.create()
    item = Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">try</span>:
        item.full_clean()
    <span class="keyword">except</span> ValidationError:
        <span class="keyword">pass</span>
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gets us back to the 302 != 200:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: 302 != 200</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s return a rendered template then, which should take care of the template
check as well:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l026)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">except</span> ValidationError:
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the tests now tell us to put the error message into the template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response</pre>
</div>
</div>
<div class="paragraph">
<p>We do that by passing a new template variable in:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l027)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">except</span> ValidationError:
        error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">error</span><span class="delimiter">"</span></span>: error})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hmm, it looks like that didn&#8217;t quite work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response</pre>
</div>
</div>
<div class="paragraph">
<p>A little print-based debug&#8230;&#8203;</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">expected_error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
print(response.content.decode())
<span class="predefined-constant">self</span>.assertContains(response, expected_error)</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;will show us the cause: Django has
<a href="https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#autoescape">HTML-escaped</a>
the apostrophe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[...]
&lt;span class="help-block"&gt;You can&amp;#39;t have an
empty list item&lt;/span&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>We could hack something like this into our test:</p>
</div>
<div class="listingblock skipme">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    expected_error = <span class="string"><span class="delimiter">"</span><span class="content">You can&amp;#39;t have an empty list item</span><span class="delimiter">"</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But using Django&#8217;s helper function is probably a better idea:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l029)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.utils.html</span> <span class="keyword">import</span> <span class="include">escape</span>
[...]

        expected_error = escape(<span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>)
        <span class="predefined-constant">self</span>.assertContains(response, expected_error)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That passes!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 11 tests in 0.047s

OK</pre>
</div>
</div>
<div class="sect3">
<h4 id="_checking_invalid_input_isn_t_saved_to_the_database">Checking Invalid Input Isn&#8217;t Saved to the Database</h4>
<div class="paragraph">
<p>Before we go further though, did you notice a little logic error we&#8217;ve allowed
to creep into our implementation?  We&#8217;re currently creating an object, even
if validation fails:</p>
</div>
<div class="listingblock sourcecode currentcontents">
<div class="title">lists/views.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    item = Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">try</span>:
        item.full_clean()
    <span class="keyword">except</span> ValidationError:
        [...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s add a new unit test to make sure that empty list items don&#8217;t get
saved:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l030-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">NewListTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_validation_errors_are_sent_back_to_home_page_template</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="keyword">def</span> <span class="function">test_invalid_list_items_arent_saved</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.client.post(<span class="string"><span class="delimiter">'</span><span class="content">/lists/new</span><span class="delimiter">'</span></span>, data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>})
        <span class="predefined-constant">self</span>.assertEqual(List.objects.count(), <span class="integer">0</span>)
        <span class="predefined-constant">self</span>.assertEqual(Item.objects.count(), <span class="integer">0</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[...]
Traceback (most recent call last):
  File "/.../superlists/lists/tests/test_views.py", line 40, in
test_invalid_list_items_arent_saved
    self.assertEqual(List.objects.count(), 0)
AssertionError: 1 != 0</pre>
</div>
</div>
<div class="paragraph">
<p>We fix it like this:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l030-2)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    list_ = List.objects.create()
    item = Item(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
    <span class="keyword">try</span>:
        item.full_clean()
        item.save()
    <span class="keyword">except</span> ValidationError:
        list_.delete()
        error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>
        <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">home.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">"</span><span class="content">error</span><span class="delimiter">"</span></span>: error})
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Do the FTs pass?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests.test_list_item_validation</strong>
[...]
File "/.../superlists/functional_tests/test_list_item_validation.py", line
29, in test_cannot_add_empty_list_items
    self.wait_for(lambda: self.assertEqual(
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .has-error</pre>
</div>
</div>
<div class="paragraph">
<p>Not quite, but they did get a little further.  Checking <em>line 29</em>, we can
see that we&#8217;ve got past the first part of the test, and are now onto the second
check&#8212;&#8203;that submitting a second empty item also shows an error.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve got some working code though, so let&#8217;s have a commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "Adjust new list view to do model validation"</strong></pre>
</div>
</div>
<div class="paragraph">
<p>
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_django_pattern_processing_post_requests_in_the_same_view_as_renders_the_form">Django Pattern: Processing POST Requests in the Same View as Renders the Form</h3>
<div class="paragraph">
<p>


This time we&#8217;ll use a slightly different approach, one that&#8217;s actually a very
common pattern in Django, which is to use the same view to process POST
requests as to render the form that they come from.  Whilst this doesn&#8217;t fit
the REST-ful URL model quite as well, it has the important advantage that the
same URL can display a form, and display any errors encountered in processing
the user&#8217;s input.</p>
</div>
<div class="paragraph">
<p>The current situation is that we have one view and URL for displaying a list,
and one view and URL for processing additions to that list.  We&#8217;re going to
combine them into one. So, in <em>list.html</em>, our form will have a different
target:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/list.html (ch11l030)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">{% block form_action %}/lists/{{ list.id }}/{% endblock %}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Incidentally, that&#8217;s another hardcoded URL.  Let&#8217;s add it to our to-do list,
and while we&#8217;re thinking about it, there&#8217;s one in <em>home.html</em> too:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Remove hardcoded URLs from views.py</em></p>
</li>
<li>
<p><em>Remove hardcoded URL from forms in list.html and home.html</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>This will immediately break our original functional test, because the
<code>view_list</code> page doesn&#8217;t know how to process POST requests yet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .has-error
[...]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this section we&#8217;re performing a refactor at the application level.
We execute our application-level refactor by changing or adding unit tests, and
then adjusting our code. We use the functional tests to tell us when our
refactor is complete and things are back to working as before.  Have
another look at the diagram from the end of <a href="/book/chapter_04.html">[chapter-4]</a> if you need to get your
bearings.

</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_refactor_transferring_the_new_item_functionality_into_view_list">Refactor: Transferring the new_item Functionality into view_list</h4>
<div class="paragraph">
<p>
Let&#8217;s take all the old tests from <code>NewItemTest</code>, the ones that are about saving
POST requests to existing lists, and move them into <code>ListViewTest</code>. As we do
so, we also make them point at the base list URL, instead of <em>&#8230;&#8203;/add_item</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l031)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):

    <span class="keyword">def</span> <span class="function">test_uses_list_template</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="keyword">def</span> <span class="function">test_passes_correct_list_to_template</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="keyword">def</span> <span class="function">test_displays_only_items_for_that_list</span>(<span class="predefined-constant">self</span>):
        [...]

    <span class="keyword">def</span> <span class="function">test_can_save_a_POST_request_to_an_existing_list</span>(<span class="predefined-constant">self</span>):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        <span class="predefined-constant">self</span>.client.post(
            <span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (correct_list.id,),
            data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>}
        )

        <span class="predefined-constant">self</span>.assertEqual(Item.objects.count(), <span class="integer">1</span>)
        new_item = Item.objects.first()
        <span class="predefined-constant">self</span>.assertEqual(new_item.text, <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>)
        <span class="predefined-constant">self</span>.assertEqual(new_item.list, correct_list)


    <span class="keyword">def</span> <span class="function">test_POST_redirects_to_list_view</span>(<span class="predefined-constant">self</span>):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        response = <span class="predefined-constant">self</span>.client.post(
            <span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (correct_list.id,),
            data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">A new item for an existing list</span><span class="delimiter">'</span></span>}
        )
        <span class="predefined-constant">self</span>.assertRedirects(response, <span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (correct_list.id,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>NewItemTest</code> class disappears completely.  I&#8217;ve also changed the
name of the redirect test to make it explicit that it only applies to POST
requests.</p>
</div>
<div class="paragraph">
<p>That gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FAIL: test_POST_redirects_to_list_view (lists.tests.test_views.ListViewTest)
AssertionError: 200 != 302 : Response didn't redirect as expected: Response
code was 200 (expected 302)
[...]
FAIL: test_can_save_a_POST_request_to_an_existing_list
(lists.tests.test_views.ListViewTest)
AssertionError: 0 != 1</pre>
</div>
</div>
<div class="paragraph">
<p>We change the <code>view_list</code> function to handle two types of request:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l032-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    <span class="keyword">if</span> request.method == <span class="string"><span class="delimiter">'</span><span class="content">POST</span><span class="delimiter">'</span></span>:
        Item.objects.create(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
        <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))
    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">list</span><span class="delimiter">'</span></span>: list_})</code></pre>
</div>
</div>
<div class="paragraph">
<p>That gets us passing tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 12 tests in 0.047s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Now we can delete the <code>add_item</code> view, since it&#8217;s no longer needed&#8230;&#8203;oops, a
couple of unexpected failures:</p>
</div>
<div class="listingblock dofirst-ch11l032-2">
<div class="content">
<pre>[...]
AttributeError: module 'lists.views' has no attribute 'add_item'
[...]
FAILED (errors=10)</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s because we&#8217;ve deleted the view, but it&#8217;s still being referred to in
<em>urls.py</em>.  We remove it from there:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/urls.py (ch11l033)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">urlpatterns = [
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that gets us to the <code>OK</code>. Let&#8217;s try a full FT run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test</strong>
[...]
ERROR: test_cannot_add_empty_list_items
[...]

Ran 16 tests in 15.276s
FAILED (errors=1)</pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re back to the one failure in our new functional test. Our refactor of the
<code>add_item</code> functionality is complete. We should commit there:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "Refactor list view to handle new item POSTs"</strong></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
So did I break the rule about never refactoring against failing tests?
    In this case, it&#8217;s allowed, because the refactor is required to get our new
    functionality to work.  You should definitely never refactor against
    failing <em>unit</em> tests.  But in my book it&#8217;s OK for the FT for the current
    story you&#8217;re working on to be failing. If you prefer a clean test run, you
    could add a skip to the current FT.
    
    
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_enforcing_model_validation_in_view_list">Enforcing Model Validation in view_list</h4>
<div class="paragraph">
<p>
We still want the addition of items to existing lists to be subject to our
model validation rules. Let&#8217;s write a new unit test for that; it&#8217;s very similar
to the one for the home page, with just a couple of tweaks:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_views.py (ch11l034)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">class</span> <span class="class">ListViewTest</span>(TestCase):
    [...]

    <span class="keyword">def</span> <span class="function">test_validation_errors_end_up_on_lists_page</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        response = <span class="predefined-constant">self</span>.client.post(
            <span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,),
            data={<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>}
        )
        <span class="predefined-constant">self</span>.assertEqual(response.status_code, <span class="integer">200</span>)
        <span class="predefined-constant">self</span>.assertTemplateUsed(response, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>)
        expected_error = escape(<span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>)
        <span class="predefined-constant">self</span>.assertContains(response, expected_error)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That should fail, because our view currently does not do any validation, and
just redirects for all POSTs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    self.assertEqual(response.status_code, 200)
AssertionError: 302 != 200</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an implementation:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l035)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    list_ = List.objects.get(id=list_id)
    error = <span class="predefined-constant">None</span>

    <span class="keyword">if</span> request.method == <span class="string"><span class="delimiter">'</span><span class="content">POST</span><span class="delimiter">'</span></span>:
        <span class="keyword">try</span>:
            item = Item(text=request.POST[<span class="string"><span class="delimiter">'</span><span class="content">item_text</span><span class="delimiter">'</span></span>], list=list_)
            item.full_clean()
            item.save()
            <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))
        <span class="keyword">except</span> ValidationError:
            error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span>

    <span class="keyword">return</span> render(request, <span class="string"><span class="delimiter">'</span><span class="content">list.html</span><span class="delimiter">'</span></span>, {<span class="string"><span class="delimiter">'</span><span class="content">list</span><span class="delimiter">'</span></span>: list_, <span class="string"><span class="delimiter">'</span><span class="content">error</span><span class="delimiter">'</span></span>: error})</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s not deeply satisfying is it? There&#8217;s definitely some duplication of code
here, that <code>try/except</code> occurs twice in <em>views.py</em>, and in general things are
feeling clunky.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Ran 13 tests in 0.047s

OK</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s wait a bit before we do more refactoring though, because we know we&#8217;re
about to do some slightly different validation coding for duplicate items.
We&#8217;ll just add it to our scratchpad for now:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Remove hardcoded URLs from views.py</em></p>
</li>
<li>
<p><em>Remove hardcoded URL from forms in list.html and home.html</em></p>
</li>
<li>
<p><em>Remove duplication of validation logic in views</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One of the reasons that the "three strikes and refactor" rule exists is
    that, if you wait until you have three use cases, each might be slightly
    different, and it gives you a better view for what the common functionality
    is. If you refactor too early, you may find that the third use case doesn&#8217;t
    quite fit with your refactored code&#8230;&#8203;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At least our functional tests are back to passing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test functional_tests</strong>
[...]
OK</pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re back to a working state, so we can take a look at some of the items on
our scratchpad.  This would be a good time for a commit. And possibly a
tea break.




</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "enforce model validation in list view"</strong></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_refactor_removing_hardcoded_urls">Refactor: Removing Hardcoded URLs</h3>
<div class="paragraph">
<p>
Do you remember those <code>name=</code> parameters in <em>urls.py</em>? We just copied
them across from the default example Django gave us, and I&#8217;ve been giving
them some reasonably descriptive names. Now we find out what they&#8217;re for.</p>
</div>
<div class="listingblock sourcecode currentcontents">
<div class="title">lists/urls.py</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^new$</span><span class="delimiter">'</span></span>, views.new_list, name=<span class="string"><span class="delimiter">'</span><span class="content">new_list</span><span class="delimiter">'</span></span>),
    url(<span class="string"><span class="modifier">r</span><span class="delimiter">'</span><span class="content">^(</span><span class="content">\d</span><span class="content">+)/$</span><span class="delimiter">'</span></span>, views.view_list, name=<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>),</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_the_url_template_tag">The {% url %} Template Tag</h4>
<div class="paragraph">
<p>We can replace the hardcoded URL in <em>home.html</em> with a Django template tag
which refers to the URL&#8217;s "name":</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/home.html (ch11l036-1)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">{% block form_action %}{% url 'new_list' %}{% endblock %}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We check that doesn&#8217;t break the unit tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s do the other template.  This one is more interesting, because we pass it
a parameter:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/templates/list.html (ch11l036-2)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html">{% block form_action %}{% url 'view_list' list.id %}{% endblock %}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check out the
<a href="https://docs.djangoproject.com/en/1.10/topics/http/urls/#reverse-resolution-of-urls">Django
docs on reverse URL resolution</a> for more info.</p>
</div>
<div class="paragraph">
<p>We run the tests again, and check they all pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
OK
$ <strong>python manage.py test functional_tests</strong>
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Excellent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "Refactor hard-coded URLs out of templates"</strong></pre>
</div>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em>Remove hardcoded URLs from views.py</em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Remove hardcoded URL from forms in list.html and home.html</span></em></p>
</li>
<li>
<p><em>Remove duplication of validation logic in views</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_get_absolute_url_for_redirects">Using get_absolute_url for Redirects</h4>
<div class="paragraph">
<p>
Now let&#8217;s tackle <em>views.py</em>. One way of doing it is just like in the
template, passing in the name of the URL and a positional argument:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l036-3)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    [...]
    <span class="keyword">return</span> redirect(<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>, list_.id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That would get the unit and functional tests passing, but the <code>redirect</code>
function can do even better magic than that!  In Django, because model objects
are often associated with a particular URL, you can define a special function
called <code>get_absolute_url</code> which says what page displays the item.  It&#8217;s useful
in this case, but it&#8217;s also useful in the Django admin (which I don&#8217;t cover in
the book, but you&#8217;ll soon discover for yourself): it will let you jump from
looking at an object in the admin view to looking at the object on the live
site. I&#8217;d always recommend defining a <code>get_absolute_url</code> for a model whenever
there is one that makes sense; it takes no time at all.</p>
</div>
<div class="paragraph">
<p>All it takes is a super-simple unit test in <em>test_models.py</em>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/tests/test_models.py (ch11l036-4)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span class="keyword">def</span> <span class="function">test_get_absolute_url</span>(<span class="predefined-constant">self</span>):
        list_ = List.objects.create()
        <span class="predefined-constant">self</span>.assertEqual(list_.get_absolute_url(), <span class="string"><span class="delimiter">'</span><span class="content">/lists/%d/</span><span class="delimiter">'</span></span> % (list_.id,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which gives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AttributeError: 'List' object has no attribute 'get_absolute_url'</pre>
</div>
</div>
<div class="paragraph">
<p>And the implementation is to use Django&#8217;s <code>reverse</code> function, which
essentially does the reverse of what Django normally does with <em>urls.py</em>
(see
<a href="https://docs.djangoproject.com/en/1.10/topics/http/urls/#reverse-resolution-of-urls">docs</a>):</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/models.py (ch11l036-5)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">from</span> <span class="include">django.core.urlresolvers</span> <span class="keyword">import</span> <span class="include">reverse</span>


<span class="keyword">class</span> <span class="class">List</span>(models.Model):

    <span class="keyword">def</span> <span class="function">get_absolute_url</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> reverse(<span class="string"><span class="delimiter">'</span><span class="content">view_list</span><span class="delimiter">'</span></span>, args=[<span class="predefined-constant">self</span>.id])</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now we can use it in the view&#8212;&#8203;the <code>redirect</code> function just takes the
object we want to redirect to, and it uses <code>get_absolute_url</code> under the
hood automagically!</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l036-6)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">new_list</span>(request):
    [...]
    <span class="keyword">return</span> redirect(list_)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s more info in the
<a href="https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#redirect">Django
docs</a>.  Quick check that the unit tests still pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OK</pre>
</div>
</div>
<div class="paragraph">
<p>Then we do the same to <code>view_list</code>:</p>
</div>
<div class="listingblock sourcecode">
<div class="title">lists/views.py (ch11l036-7)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span class="keyword">def</span> <span class="function">view_list</span>(request, list_id):
    [...]

            item.save()
            <span class="keyword">return</span> redirect(list_)
        <span class="keyword">except</span> ValidationError:
            error = <span class="string"><span class="delimiter">"</span><span class="content">You can't have an empty list item</span><span class="delimiter">"</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And a full unit test and functional test run to assure ourselves that
everything still works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>python manage.py test lists</strong>
OK
$ <strong>python manage.py test functional_tests</strong>
OK</pre>
</div>
</div>
<div class="paragraph">
<p>Cross off our to-dos:</p>
</div>
<div class="sidebarblock scratchpad">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><em><span class="strikethrough line-through">Remove hardcoded URLs from views.py</span></em></p>
</li>
<li>
<p><em><span class="strikethrough line-through">Remove hardcoded URL from forms in list.html and home.html</span></em></p>
</li>
<li>
<p><em>Remove duplication of validation logic in views</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s do a commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ <strong>git commit -am "Use get_absolute_url on List model to DRY urls in views"</strong></pre>
</div>
</div>
<div class="paragraph">
<p>That final to-do item will be the subject of the next chapter&#8230;&#8203;

</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Tips on Organising Tests and Refactoring</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Use a tests folder</dt>
<dd>
<p>Just as you use multiple files to hold your application code, you should
split your tests out into multiple files.
+</p>
<div class="ulist">
<ul>
<li>
<p>Use a folder called <em>tests</em>, with a <i>__init__.py</i>.</p>
</li>
<li>
<p>For functional tests, group them into tests for a particular feature or
user story.</p>
</li>
<li>
<p>For unit tests, you want a separate test file for each tested source code
file. For Django, that&#8217;s typically <em>test_models.py</em>, <em>test_views.py</em>, and
<em>test_forms.py</em>.</p>
</li>
<li>
<p>Have at least a placeholder test for <em>every</em> function and class.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Don&#8217;t forget the "Refactor" in "Red, Green, Refactor"</dt>
<dd>
<p>The whole point of having tests is to allow you to refactor your code!
Use them, and make your code as clean as you can.</p>
</dd>
<dt class="hdlist1">Don&#8217;t refactor against failing tests</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>In general!</p>
</li>
<li>
<p>But the FT you&#8217;re currently working on doesn&#8217;t count.</p>
</li>
<li>
<p>You can occasionally put a skip on a test which is testing something you
haven&#8217;t written yet.</p>
</li>
<li>
<p>More commonly, make a note of the refactor you want to do, finish what
you&#8217;re working on, and do the refactor a little later, when you&#8217;re back
to a working state.</p>
</li>
<li>
<p>Don&#8217;t forget to remove any skips before you commit your code! You should
always review your diffs line by line to catch things like this.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. "Dunder" is shorthand for double-underscore, so "dunderinit" means <i>__init__.py</i>.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-02-11 09:11:21 GMT
</div>
</div>
<div class="comments" style="padding: 20px">
  <h3>Comments</h3>
  <div id="disqus_thread"></div>

  <script type="text/javascript">
var disqus_shortname = 'obeythetestinggoat';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
  </script>

  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<html><head><script>   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-40928035-1', 'obeythetestinggoat.com');   ga('send', 'pageview');  </script>
</head></html></body>
</html>